<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Dashboard - Annotations Example</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #333333;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: #666666;
            font-size: 14px;
        }

        /* REVENUE LABEL CHANGE: Badge to show which version this is */
        .version-badge {
            display: inline-block;
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 8px;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        select {
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 200px;
        }

        select:hover {
            border-color: #f97316;
            background: #ffffff;
        }

        select:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .stats-row {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #f5f5f5;
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666666;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        .stat-value.positive { color: #4ade80; }
        .stat-value.negative { color: #f87171; }
        .stat-value.neutral { color: #fbbf24; }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333333;
        }

        .chart-subtitle {
            font-size: 13px;
            color: #666666;
        }

        .chart-range-select {
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-range-select:hover {
            border-color: #f97316;
            background: #ffffff;
        }

        .chart-range-select:focus {
            outline: none;
            border-color: #f97316;
        }

        .legend {
            display: flex;
            gap: 24px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333333;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.our-data { background: linear-gradient(135deg, #f97316, #fb923c); }
        .legend-dot.ahrefs { background: linear-gradient(135deg, #3b82f6, #60a5fa); }
        .legend-dot.revenue { background: linear-gradient(135deg, #10b981, #34d399); }
        .legend-dot.dr { background: linear-gradient(135deg, #a855f7, #c084fc); }

        #chart-container {
            min-height: 400px;
        }

        /* DR Stat Card Styles */
        .dr-stat-card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 20px 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            min-width: 140px;
        }

        .dr-stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666666;
            margin-bottom: 4px;
        }

        .dr-stat-value {
            font-size: 32px;
            font-weight: 700;
            color: #a855f7;
            line-height: 1;
            margin-bottom: 8px;
        }

        .dr-sparkline {
            width: 100px;
            height: 30px;
        }

        .header-stats {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        /* REVENUE LABEL CHANGE: Toggle styled like legend item */
        .legend-toggle {
            transition: opacity 0.2s ease;
            user-select: none;
        }

        .legend-toggle.inactive {
            opacity: 0.35;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Traffic Comparison Dashboard</h1>
        <p>Our Data vs Ahrefs â€” All Available Data</p>
        <!-- REVENUE LABEL CHANGE: Version indicator -->
        <div class="version-badge">Annotations Approach</div>
    </div>

    <div class="header-stats">
        <div class="dr-stat-card" id="drStatCard" style="display: none;">
            <div class="dr-stat-label">Domain Rating</div>
            <div class="dr-stat-value" id="drValue">--</div>
            <div class="dr-sparkline" id="drSparkline"></div>
        </div>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-dot our-data"></div>
            <span>Our Data</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot ahrefs"></div>
            <span>Ahrefs</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot revenue"></div>
            <span>Revenue</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot dr"></div>
            <span>DR</span>
        </div>
        <!-- REVENUE LABEL CHANGE: Toggle styled like legend item -->
        <div class="legend-item legend-toggle" id="revenueLabelToggle" style="cursor: pointer; opacity: 1;">
            <div class="legend-dot" style="background: linear-gradient(135deg, #047857, #10b981); font-size: 8px; display: flex; align-items: center; justify-content: center; color: white;">$</div>
            <span>Labels</span>
        </div>
    </div>

    <div class="controls">
        <select id="domainSelect">
            <option value="">Select Domain</option>
        </select>
    </div>

    <div id="charts"></div>
    <div id="loading" style="display: none; text-align: center; padding: 40px; color: #666666;">
        <div style="font-size: 16px; margin-bottom: 12px;">Loading data...</div>
        <div style="font-size: 13px; color: #999999;">Parsing CSV files</div>
    </div>
    <div id="error" style="display: none; text-align: center; padding: 40px;">
        <div style="background: #fee; border: 1px solid #fcc; border-radius: 12px; padding: 24px; color: #c33;">
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Data</div>
            <div style="font-size: 13px;" id="error-message"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        let domains = {};
        
        // REVENUE LABEL CHANGE: Track toggle state, chart instance, and annotations for dynamic update
        let showRevenueLabels = true;
        let currentChart = null;
        let currentAnnotations = [];
        
        // Fallback hardcoded data (used if CSV loading fails or for file:// protocol)
        const fallbackData = {
            "lyncconf.com": {
                "rank": 1,
                "dates": ["Jun 4 2025", "Jun 6 2025", "Jun 9 2025", "Jun 11 2025", "Jun 13 2025", "Jun 15 2025", "Jun 16 2025", "Jun 17 2025", "Jun 18 2025", "Jun 19 2025", "Jun 20 2025", "Jun 21 2025", "Jun 22 2025", "Jun 23 2025", "Jun 24 2025", "Jun 25 2025", "Jun 26 2025", "Jun 27 2025", "Jun 28 2025", "Jun 29 2025", "Jun 30 2025", "Jul 1 2025", "Jul 2 2025", "Jul 3 2025", "Jul 4 2025", "Jul 5 2025", "Jul 6 2025", "Jul 7 2025", "Jul 8 2025", "Jul 9 2025", "Jul 10 2025", "Jul 11 2025", "Jul 12 2025", "Jul 13 2025", "Jul 14 2025", "Jul 15 2025", "Jul 16 2025", "Jul 17 2025", "Jul 18 2025", "Jul 19 2025", "Jul 20 2025", "Jul 21 2025", "Jul 22 2025", "Jul 23 2025", "Jul 24 2025", "Jul 25 2025", "Jul 26 2025", "Jul 27 2025", "Jul 28 2025", "Jul 29 2025", "Jul 30 2025", "Jul 31 2025", "Aug 1 2025", "Aug 2 2025", "Aug 3 2025", "Aug 4 2025", "Aug 5 2025", "Aug 6 2025", "Aug 7 2025", "Aug 8 2025", "Aug 9 2025", "Aug 10 2025", "Aug 11 2025", "Aug 12 2025", "Aug 13 2025", "Aug 14 2025", "Aug 15 2025", "Aug 16 2025", "Aug 17 2025", "Aug 18 2025", "Aug 19 2025", "Aug 20 2025", "Aug 21 2025", "Aug 22 2025", "Aug 23 2025", "Aug 24 2025", "Aug 25 2025", "Aug 26 2025", "Aug 27 2025", "Aug 28 2025", "Aug 29 2025", "Aug 30 2025", "Aug 31 2025", "Sep 1 2025", "Sep 2 2025", "Sep 3 2025", "Sep 4 2025", "Sep 5 2025", "Sep 6 2025", "Sep 7 2025", "Sep 8 2025", "Sep 9 2025", "Sep 10 2025", "Sep 11 2025", "Sep 12 2025", "Sep 13 2025", "Sep 14 2025", "Sep 15 2025", "Sep 16 2025", "Sep 17 2025", "Sep 18 2025", "Sep 19 2025", "Sep 20 2025", "Sep 21 2025", "Sep 22 2025", "Sep 23 2025", "Sep 24 2025", "Sep 25 2025", "Sep 26 2025", "Sep 27 2025", "Sep 28 2025", "Sep 29 2025", "Sep 30 2025", "Oct 1 2025", "Oct 2 2025", "Oct 3 2025", "Oct 4 2025", "Oct 5 2025", "Oct 6 2025", "Oct 7 2025", "Oct 8 2025", "Oct 9 2025", "Oct 10 2025", "Oct 11 2025", "Oct 12 2025", "Oct 13 2025", "Oct 14 2025", "Oct 15 2025", "Oct 16 2025", "Oct 17 2025", "Oct 18 2025", "Oct 19 2025", "Oct 20 2025", "Oct 21 2025", "Oct 22 2025", "Oct 23 2025", "Oct 24 2025", "Oct 25 2025", "Oct 26 2025", "Oct 27 2025", "Oct 28 2025", "Oct 29 2025", "Oct 30 2025", "Oct 31 2025", "Nov 1 2025", "Nov 2 2025", "Nov 3 2025", "Nov 4 2025", "Nov 5 2025", "Nov 6 2025", "Nov 7 2025", "Nov 8 2025", "Nov 9 2025", "Nov 10 2025", "Nov 11 2025", "Nov 12 2025", "Nov 13 2025", "Nov 14 2025", "Nov 15 2025", "Nov 16 2025", "Nov 17 2025", "Nov 18 2025", "Nov 19 2025", "Nov 20 2025", "Nov 21 2025", "Nov 22 2025", "Nov 23 2025", "Nov 24 2025", "Nov 25 2025", "Nov 26 2025", "Nov 27 2025", "Nov 28 2025", "Nov 29 2025", "Nov 30 2025", "Dec 1 2025", "Dec 2 2025", "Dec 3 2025", "Dec 4 2025", "Dec 5 2025", "Dec 6 2025", "Dec 7 2025", "Dec 8 2025", "Dec 9 2025", "Dec 10 2025", "Dec 11 2025", "Dec 12 2025", "Dec 13 2025", "Dec 14 2025", "Dec 15 2025", "Dec 16 2025", "Dec 17 2025", "Dec 18 2025", "Dec 19 2025", "Dec 20 2025", "Dec 21 2025", "Dec 22 2025", "Dec 23 2025", "Dec 24 2025", "Dec 25 2025", "Dec 26 2025", "Dec 27 2025", "Dec 28 2025", "Dec 29 2025", "Dec 30 2025", "Dec 31 2025", "Jan 1 2026", "Jan 2 2026", "Jan 3 2026", "Jan 4 2026", "Jan 5 2026", "Jan 6 2026", "Jan 7 2026", "Jan 8 2026", "Jan 9 2026", "Jan 10 2026", "Jan 11 2026", "Jan 12 2026", "Jan 13 2026"],
                "ourData": [21181, 12214, 14683, 14853, 14853, 15828, 16243, 15436, 14741, 14591, 14727, 13648, 13652, 13630, 12950, 12785, 12250, 12168, 12758, 14113, 13908, 14377, 15564, 15544, 31400, 18697, 17470, 17697, 17702, 17436, 17045, null, null, null, 16256, 15751, 16753, 16786, 18064, 18444, 18560, 18826, 18574, 17890, null, 17453, 17140, 17515, 17472, 17966, 17692, 17796, 17788, 17691, 17966, 18013, 17807, 18917, 18062, 19593, 19893, 19857, 20241, 21025, 20957, 20979, 20757, 21519, 21324, 21689, 21238, 22351, 22236, 22078, 22354, 22372, 22572, 22134, 25845, 25669, 25275, 25641, 25896, 27240, 26132, 25311, 27678, 26710, 22632, 22060, 21772, 20044, 19439, 20014, 20337, 20468, 22754, 22839, 22863, 22027, 23249, 23045, 20593, 20627, 19835, 19944, 20549, 22075, 22146, 21869, 22935, 22359, 21876, 21857, 22162, 21277, 20967, 20787, 21752, 21080, 21134, 35709, 34312, 39097, 38726, 38991, 38769, 38588, 38377, 42276, 41954, 41584, 42779, 42335, 41994, 41333, 41222, 41196, 41253, 41331, 40501, 40914, 39037, 36227, 35709, 36243, 37719, 37708, 37206, 37153, 36398, 35574, 34636, 34273, 33938, 33092, 33291, 37877, 37846, 40497, 41423, 37901, 37756, 34484, 32813, 32759, 31730, 31411, 31133, 35860, 35727, 35466, 35534, 33597, 33725, 33969, 33876, 33239, 29435, 29435, 29435, 29499, 29318, 29332, 29060, 29056, 33879, 32360, 31831, 32154, 31830, 32360, 32273, 30332, 26822, 25631, 25645, 27155, 26979, 27054, 28928, 28757, 29755, 29266, 29757, 29253, 29255, 33132, 33346, 33206, 33196, 31908, 31758, 31450, 31720, 31528, 31688, 33221],
                "ahrefsData": [17528, 17527, 17186, 17523, 18024, 17792, 17977, 17593, 17404, 17257, 17189, 17204, 17218, 17231, 16822, 16528, 16154, 16641, 16946, 17137, 17012, 17271, 18026, 17927, 18299, 17851, 17701, 17802, 17731, 17337, 16765, 16442, 15874, 15386, 15074, 14772, 14817, 14566, 14575, 14401, 14444, 14705, 14532, 14530, 14220, 14379, 14276, 14016, 13828, 14019, 14058, 14039, 14200, 14291, 14674, 15683, 16767, 16973, 16861, 16951, 17571, 17970, 17935, 18359, 18498, 17629, 18192, 18461, 18206, 18342, 18807, 18556, 18453, 18828, 18855, 18331, 18499, 18902, 19215, 19260, 18655, 18479, 19183, 26261, 27209, 31515, 32057, 37858, 39789, 41136, 43910, 43490, 44102, 44949, 49039, 53254, 54810, 55483, 55860, 59064, 59505, 60087, 59502, 59714, 61523, 62437, 66084, 66295, 65929, 66803, 67012, 66667, 65457, 65294, 77416, 78362, 80187, 82054, 82102, 83507, 85663, 85012, 84857, 87302, 86783, 90198, 89738, 89679, 89303, 89287, 88653, 89210, 89792, 89049, 89206, 89521, 89308, 89491, 89589, 89437, 90023, 87930, 87415, 87761, 87824, 83780, 80815, 81108, 81137, 80606, 78352, 76677, 75936, 74946, 75697, 75902, 72775, 72194, 71603, 72297, 63810, 64307, 62909, 61219, 59119, 59079, 59178, 58832, 58824, 58272, 58092, 57793, 56335, 55104, 54808, 54797, 52267, 49815, 49815, 49815, 49804, 49030, 47758, 47372, 47377, 47392, 44775, 43091, 44252, 43685, 44094, 44010, 41503, 39458, 37858, 37163, 37451, 37281, 37832, 37197, 37162, 36846, 35246, 34897, 34439, 34555, 34444, 34729, 34686, 34582, 33974, 33946, 33551, 33270, 33193, 33178, 33322, 33180],
                "drData": [67, 67, 67, 68, 68, 69, 70, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 71, 72, 72, 72, 71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 70, 70, 70, 70, 70, 70, 70, 70, 70, 69, 70, 70, 70, 69, 69, 69, 69, 69, 69, 68, 68, 68, 68, 68, 68, 68, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71],
                "ourChange": "+56.8%",
                "ahrefsChange": "+89.3%"
            }
        };

        function getStatClass(value) {
            const num = parseFloat(value);
            if (num > 5) return 'positive';
            if (num < -5) return 'negative';
            return 'neutral';
        }

        // Linear interpolation for missing data
        function interpolateData(arr) {
            const real = [...arr];
            const estimated = new Array(arr.length).fill(null);
            const isEstimated = new Array(arr.length).fill(false);
            
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === null) {
                    let prevIdx = i - 1;
                    while (prevIdx >= 0 && arr[prevIdx] === null) prevIdx--;
                    
                    let nextIdx = i + 1;
                    while (nextIdx < arr.length && arr[nextIdx] === null) nextIdx++;
                    
                    if (prevIdx >= 0 && nextIdx < arr.length) {
                        const prevVal = arr[prevIdx];
                        const nextVal = arr[nextIdx];
                        const steps = nextIdx - prevIdx;
                        const step = (nextVal - prevVal) / steps;
                        const interpolated = Math.round(prevVal + step * (i - prevIdx));
                        
                        real[i] = interpolated;
                        estimated[i] = interpolated;
                        isEstimated[i] = true;
                    }
                }
            }
            
            return { real, estimated, isEstimated };
        }

        // Filter data by date range
        function filterByDateRange(data, days) {
            if (days === 'all') {
                return {
                    dates: data.dates,
                    ourData: data.ourData,
                    ahrefsData: data.ahrefsData,
                    drData: data.drData || []
                };
            }
            
            // Special case: From December 2024
            if (days === 'dec2024') {
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const startDate = new Date(2024, 11, 1); // Dec 1, 2024
                
                // Find the first index where date >= Dec 1, 2024
                let startIdx = 0;
                for (let i = 0; i < data.dates.length; i++) {
                    const parts = data.dates[i].split(' ');
                    if (parts.length === 3) {
                        const [month, day, year] = parts;
                        const monthIndex = monthNames.indexOf(month);
                        const dateObj = new Date(parseInt(year), monthIndex, parseInt(day));
                        if (dateObj >= startDate) {
                            startIdx = i;
                            break;
                        }
                    }
                }
                
                return {
                    dates: data.dates.slice(startIdx),
                    ourData: data.ourData.slice(startIdx),
                    ahrefsData: data.ahrefsData.slice(startIdx),
                    drData: (data.drData || []).slice(startIdx)
                };
            }
            
            const numDays = parseInt(days);
            const totalPoints = data.dates.length;
            const startIdx = Math.max(0, totalPoints - numDays);
            
            return {
                dates: data.dates.slice(startIdx),
                ourData: data.ourData.slice(startIdx),
                ahrefsData: data.ahrefsData.slice(startIdx),
                drData: (data.drData || []).slice(startIdx)
            };
        }

        // REVENUE LABEL CHANGE: Modified to also return annotation data for labels
        // Generate monthly revenue with strict normalization and timestamp-based stepped blocks
        function generateMonthlyRevenue(dates, monthlyRevenueData = null) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Use CSV data if provided, otherwise use default
            const monthRevenue = monthlyRevenueData || {
                'Jun2025': 100, 'Jul2025': 200, 'Aug2025': 300, 'Sep2025': 400,
                'Oct2025': 500, 'Nov2025': 600, 'Dec2025': 700, 'Jan2026': 800
            };
            
            // Helper: Parse "Jan 1 2024" to timestamp
            function parseDateToTimestamp(dateStr) {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return null;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return null;
                return new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
            }
            
            // STEP 1: Normalize & De-Duplicate by YYYY-MM
            // Create a Map keyed by YYYY-MM, keeping latest value per month
            const normalizedMap = new Map();
            
            // First, extract unique months from dates array
            dates.forEach(dateStr => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return;
                
                // Key: YYYY-MM format for sorting
                const key = `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
                // Revenue key format: "Jun2025"
                const revenueKey = month + year;
                const revenueValue = monthRevenue[revenueKey] || 0;
                
                // Keep latest value (overwrites if exists)
                normalizedMap.set(key, {
                    year: parseInt(year),
                    monthIndex: monthIndex,
                    month: month,
                    revenue: revenueValue
                });
            });
            
            // Sort keys chronologically
            const sortedKeys = Array.from(normalizedMap.keys()).sort();
            
            // STEP 2: Generate Stepped Area Blocks (3 points per month)
            const revenuePoints = [];
            
            // REVENUE LABEL CHANGE: Also build annotations array for point annotations
            const revenueAnnotations = [];
            
            sortedKeys.forEach(key => {
                const info = normalizedMap.get(key);
                const revenue = info.revenue;
                
                // Start Date: 1st of the month
                const startDate = new Date(info.year, info.monthIndex, 1);
                
                // End Date: Start + 25 days
                const endDate = new Date(info.year, info.monthIndex, 26); // Day 26
                
                // Cut Date: Start + 26 days (creates sharp drop)
                const cutDate = new Date(info.year, info.monthIndex, 27); // Day 27
                
                // Push 3 points for stepped area
                revenuePoints.push({ x: startDate.getTime(), y: revenue });
                revenuePoints.push({ x: endDate.getTime(), y: revenue });
                revenuePoints.push({ x: cutDate.getTime(), y: 0 });
                
                // REVENUE LABEL CHANGE: Create point annotation at center of bar (day 13)
                // Only add annotation if revenue > 0
                if (revenue > 0) {
                    const midDate = new Date(info.year, info.monthIndex, 13);
                    revenueAnnotations.push({
                        x: midDate.getTime(),
                        y: revenue,
                        label: '$' + revenue.toLocaleString(),
                        month: info.month,
                        year: info.year
                    });
                }
            });
            
            // SAFETY CHECK: Sort by timestamp
            revenuePoints.sort((a, b) => a.x - b.x);
            
            // Log for verification
            console.log('ðŸ“Š Revenue Data Processed:', {
                uniqueMonths: sortedKeys.length,
                totalPoints: revenuePoints.length,
                expectedPoints: sortedKeys.length * 3,
                firstMonth: sortedKeys[0],
                lastMonth: sortedKeys[sortedKeys.length - 1],
                samplePoints: revenuePoints.slice(0, 6),
                annotations: revenueAnnotations.length // REVENUE LABEL CHANGE
            });
            
            // Also generate categories array for x-axis labels (mid-month positioned)
            const categories = new Array(dates.length).fill(' ');
            
            // Find mid-month indices for labels
            const monthIndices = {};
            dates.forEach((dateStr, idx) => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                const [month, day, year] = parts;
                const key = month + year;
                if (!monthIndices[key]) {
                    monthIndices[key] = { firstIdx: idx, lastIdx: idx, month, year };
                } else {
                    monthIndices[key].lastIdx = idx;
                }
            });
            
            Object.entries(monthIndices).forEach(([key, info]) => {
                const midIdx = Math.floor((info.firstIdx + info.lastIdx) / 2);
                categories[midIdx] = info.month + ' ' + info.year;
            });
            
            // REVENUE LABEL CHANGE: Return annotations array as well
            return { revenuePoints, categories, revenueAnnotations };
        }

        // Calculate change percentage for filtered data
        function calcChange(arr) {
            const validData = arr.filter(v => v !== null && v !== undefined);
            if (validData.length < 2) return 'N/A';
            const first = validData[0];
            const last = validData[validData.length - 1];
            const change = ((last - first) / first * 100).toFixed(1);
            return (change >= 0 ? '+' : '') + change + '%';
        }

        // DR Sparkline chart instance (to destroy on re-render)
        let drSparklineChart = null;
        
        function renderDRStatCard(drData, dates) {
            const card = document.getElementById('drStatCard');
            const valueEl = document.getElementById('drValue');
            const sparklineEl = document.getElementById('drSparkline');
            
            // Filter out null values and get valid DR data
            const validDR = drData.filter(v => v !== null && v !== undefined);
            
            if (validDR.length === 0) {
                card.style.display = 'none';
                return;
            }
            
            // Show card and set latest value
            card.style.display = 'flex';
            const latestDR = validDR[validDR.length - 1];
            valueEl.textContent = latestDR;
            
            // Destroy previous sparkline if exists
            if (drSparklineChart) {
                drSparklineChart.destroy();
                drSparklineChart = null;
            }
            
            // Create sparkline data (use last 90 data points max for cleaner sparkline)
            const sparklineData = validDR.slice(-90);
            
            const sparklineOptions = {
                series: [{
                    data: sparklineData
                }],
                chart: {
                    type: 'line',
                    width: 100,
                    height: 30,
                    sparkline: { enabled: true },
                    animations: { enabled: false }
                },
                stroke: {
                    curve: 'smooth',
                    width: 2
                },
                colors: ['#a855f7'],
                tooltip: { enabled: false }
            };
            
            drSparklineChart = new ApexCharts(sparklineEl, sparklineOptions);
            drSparklineChart.render();
        }

        function createChart(domain, data, dateRange = 'dec2024') {
            // REVENUE LABEL CHANGE: Destroy previous chart if exists
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            const chartsDiv = document.getElementById('charts');
            chartsDiv.innerHTML = '';

            const filtered = filterByDateRange(data, dateRange);

            const card = document.createElement('div');
            card.className = 'card';

            card.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${domain}</div>
                    </div>
                    <select class="chart-range-select" id="chartDateRange">
                        <option value="7" ${dateRange === '7' ? 'selected' : ''}>Last 7 days</option>
                        <option value="30" ${dateRange === '30' ? 'selected' : ''}>Last month</option>
                        <option value="90" ${dateRange === '90' ? 'selected' : ''}>Last 3 months</option>
                        <option value="180" ${dateRange === '180' ? 'selected' : ''}>Last 6 months</option>
                        <option value="365" ${dateRange === '365' ? 'selected' : ''}>Last year</option>
                        <option value="dec2024" ${dateRange === 'dec2024' ? 'selected' : ''}>From Dec 2024</option>
                        <option value="all" ${dateRange === 'all' ? 'selected' : ''}>All time</option>
                    </select>
                </div>
                <div id="apex-chart"></div>
            `;
            chartsDiv.appendChild(card);

            document.getElementById('chartDateRange').addEventListener('change', function() {
                createChart(domain, data, this.value);
            });

            const ourProcessed = interpolateData(filtered.ourData);
            const ahrefsProcessed = interpolateData(filtered.ahrefsData);
            const drProcessed = interpolateData(filtered.drData || []);
            const revenueResult = generateMonthlyRevenue(filtered.dates, data.monthlyRevenue);
            
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Convert traffic data to timestamp-based {x, y} format
            function convertToTimestampData(dates, values) {
                return dates.map((dateStr, idx) => {
                    const parts = dateStr.split(' ');
                    if (parts.length !== 3) return null;
                    const [month, day, year] = parts;
                    const monthIndex = monthNames.indexOf(month);
                    if (monthIndex === -1) return null;
                    const timestamp = new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
                    return { x: timestamp, y: values[idx] };
                }).filter(p => p !== null);
            }
            
            const ourDataPoints = convertToTimestampData(filtered.dates, ourProcessed.real);
            const ahrefsDataPoints = convertToTimestampData(filtered.dates, ahrefsProcessed.real);
            const drDataPoints = convertToTimestampData(filtered.dates, drProcessed.real);
            const revenuePoints = revenueResult.revenuePoints;
            
            // Calculate max revenue for "bottom-third" axis scaling
            const maxRevenue = Math.max(...revenuePoints.map(p => p.y || 0), 1);
            const revenueAxisMax = maxRevenue * 3;
            
            // Render DR Stat Card with Sparkline
            renderDRStatCard(data.drData || [], filtered.dates);

            // REVENUE LABEL CHANGE: Build point annotations and store globally for toggle
            currentAnnotations = revenueResult.revenueAnnotations.map(ann => ({
                x: ann.x,
                y: ann.y,
                yAxisIndex: 2, // Revenue y-axis
                seriesIndex: 2, // Revenue series
                marker: {
                    size: 0 // Hide the marker dot
                },
                label: {
                    borderColor: 'transparent',
                    borderWidth: 0,
                    text: ann.label,
                    style: {
                        background: 'transparent',
                        color: '#047857', // Dark green for visibility
                        fontSize: '10px',
                        fontWeight: 600,
                        fontFamily: 'Inter, sans-serif',
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    offsetY: 25, // Push label down toward bottom of bar
                    offsetX: 0
                }
            }));
            
            // Use annotations based on current toggle state
            const pointAnnotations = showRevenueLabels ? currentAnnotations : [];

            const options = {
                series: [{
                    name: 'Our Data',
                    type: 'area',
                    data: ourDataPoints
                }, {
                    name: 'Ahrefs',
                    type: 'area',
                    data: ahrefsDataPoints
                }, {
                    name: 'Revenue',
                    type: 'area',
                    data: revenuePoints
                }, {
                    name: 'DR',
                    type: 'line',
                    data: drDataPoints
                }],
                chart: {
                    type: 'line',
                    height: 480,
                    background: 'transparent',
                    toolbar: { show: true, tools: { download: true, zoom: true, pan: true } },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    },
                    stacked: false
                },
                // REVENUE LABEL CHANGE: Add annotations section
                annotations: {
                    points: pointAnnotations
                },
                colors: ['#f97316', '#3b82f6', '#10b981', '#a855f7'],
                fill: {
                    type: ['solid', 'solid', 'solid', 'solid'],
                    opacity: [0, 0, 0.25, 0]
                },
                stroke: {
                    curve: ['smooth', 'smooth', 'stepline', 'straight'],
                    width: [2, 2, 0, 3],
                    dashArray: [0, 0, 0, 6] // DR is dotted line (thicker dash)
                },
                markers: {
                    size: [0, 0, 0, 2], // Small markers for DR to make line visible
                    hover: { size: 5 },
                    strokeWidth: 0
                },
                xaxis: {
                    type: 'datetime',
                    labels: {
                        style: { colors: '#333333', fontSize: '11px', fontWeight: 500 },
                        rotate: 0,
                        rotateAlways: false,
                        hideOverlappingLabels: true,
                        datetimeUTC: false,
                        format: 'MMM yyyy',
                        offsetX: 15, // Nudge labels right to center on Day 1-25 blocks
                        datetimeFormatter: {
                            year: 'yyyy',
                            month: 'MMM yyyy',
                            day: 'dd MMM',
                            hour: 'HH:mm'
                        }
                    },
                    axisBorder: { color: '#cccccc' },
                    axisTicks: { show: false },
                    crosshairs: {
                        show: true,
                        stroke: { color: '#999999', width: 1, dashArray: 3 }
                    },
                    tooltip: { enabled: true, format: 'dd MMM yyyy' }
                },
                yaxis: [
                    // [0] Our Data - Left Axis (Primary Traffic)
                    {
                        seriesName: 'Our Data',
                        title: {
                            text: 'Traffic',
                            style: { color: '#333333', fontSize: '12px' }
                        },
                        labels: {
                            style: { colors: '#333333' },
                            formatter: val => val ? val.toLocaleString() : ''
                        },
                        min: 0
                    },
                    // [1] Ahrefs - Left Axis (Linked to Our Data axis)
                    {
                        seriesName: 'Ahrefs',
                        show: false, // Hide duplicate axis, shares scale with Our Data
                        labels: {
                            style: { colors: '#333333' },
                            formatter: val => val ? val.toLocaleString() : ''
                        },
                        min: 0
                    },
                    // [2] Revenue - Right Axis A (Bottom-third logic)
                    {
                        seriesName: 'Revenue',
                        opposite: true,
                        title: {
                            text: 'Revenue ($)',
                            style: { color: '#10b981', fontSize: '12px' }
                        },
                        labels: {
                            style: { colors: '#10b981' },
                            formatter: val => val ? '$' + val.toLocaleString() : ''
                        },
                        min: 0,
                        max: revenueAxisMax // Bottom-third logic: max = maxRevenue * 3
                    },
                    // [3] DR - Right Axis B (Offset, 0-100 scale)
                    {
                        seriesName: 'DR',
                        opposite: true,
                        title: {
                            text: 'DR',
                            style: { color: '#a855f7', fontSize: '12px' },
                            offsetX: -10
                        },
                        labels: {
                            style: { colors: '#a855f7' },
                            formatter: val => val ? val.toFixed(0) : '',
                            offsetX: -10
                        },
                        min: 0,
                        max: 100,
                        tickAmount: 5,
                        axisBorder: {
                            show: true,
                            color: '#a855f7',
                            offsetX: -5
                        }
                    }
                ],
                grid: {
                    borderColor: '#e8e8e8',
                    strokeDashArray: 0,
                    padding: {
                        left: 20,
                        right: 40, // Extra space for DR axis
                        bottom: 15
                    }
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'left',
                    offsetY: 0,
                    labels: { colors: '#333333' },
                    markers: { width: 10, height: 10, radius: 10 }
                },
                tooltip: {
                    enabled: true,
                    shared: true,
                    intersect: false,
                    followCursor: true,
                    fixed: {
                        enabled: false
                    },
                    custom: function({ series, seriesIndex, dataPointIndex, w }) {
                        const colors = ['#f97316', '#3b82f6', '#10b981', '#a855f7'];
                        const names = ['Our Data', 'Ahrefs', 'Revenue', 'DR'];
                        
                        // Get the x value (timestamp) from the HOVERED series
                        const hoveredSeriesData = w.config.series[seriesIndex].data;
                        const hoveredPoint = hoveredSeriesData[dataPointIndex];
                        const xValue = hoveredPoint?.x;
                        
                        if (!xValue) return '';
                        
                        const date = new Date(xValue);
                        const dateStr = date.toLocaleDateString('en-GB', { 
                            day: 'numeric', 
                            month: 'short', 
                            year: 'numeric' 
                        });
                        
                        let html = '<div class="apexcharts-tooltip-custom" style="padding: 10px; background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.12);">';
                        html += '<div style="font-weight: 600; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #eee; color: #333;">' + dateStr + '</div>';
                        
                        // Loop through all 4 series and find matching data by timestamp
                        for (let i = 0; i < 4; i++) {
                            const seriesData = w.config.series[i].data;
                            let value = null;
                            
                            // Find the closest point by timestamp
                            let closestDiff = Infinity;
                            const maxDiff = i === 2 ? 20 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000; // 20 days for revenue, 1 day for others
                            
                            for (let j = 0; j < seriesData.length; j++) {
                                const point = seriesData[j];
                                if (point && point.x !== undefined) {
                                    const diff = Math.abs(point.x - xValue);
                                    if (diff < closestDiff && diff <= maxDiff) {
                                        closestDiff = diff;
                                        value = point.y;
                                    }
                                }
                            }
                            
                            // Format value
                            let displayValue = 'â€”';
                            if (value !== null && value !== undefined) {
                                if (i === 2) {
                                    displayValue = '$' + value.toLocaleString();
                                } else if (i === 3) {
                                    displayValue = value.toFixed(0);
                                } else if (value !== 0) {
                                    displayValue = value.toLocaleString() + ' visits';
                                }
                            }
                            
                            // Skip revenue if no data found (null)
                            if (i === 2 && value === null) {
                                continue;
                            }
                            
                            // Skip DR if no data found
                            if (i === 3 && value === null) {
                                continue;
                            }
                            
                            html += '<div style="display: flex; align-items: center; padding: 4px 0;">';
                            html += '<span style="width: 10px; height: 10px; border-radius: 50%; background: ' + colors[i] + '; margin-right: 8px;"></span>';
                            html += '<span style="color: #666; min-width: 70px;">' + names[i] + ':</span>';
                            html += '<span style="font-weight: 600; color: #333; margin-left: auto;">' + displayValue + '</span>';
                            html += '</div>';
                        }
                        
                        html += '</div>';
                        return html;
                    }
                },
                dataLabels: { enabled: false }
            };

            const chart = new ApexCharts(document.querySelector('#apex-chart'), options);
            chart.render();
            
            // REVENUE LABEL CHANGE: Store chart instance for dynamic updates
            currentChart = chart;
            
            // Make tooltip follow cursor on Y axis
            const chartEl = document.querySelector('#apex-chart');
            chartEl.addEventListener('mousemove', function(e) {
                const tooltip = chartEl.querySelector('.apexcharts-tooltip');
                if (tooltip && tooltip.classList.contains('apexcharts-active')) {
                    const chartRect = chartEl.getBoundingClientRect();
                    const mouseY = e.clientY - chartRect.top;
                    const tooltipHeight = tooltip.offsetHeight;
                    
                    // Position tooltip near cursor Y, with some offset
                    let newTop = mouseY - tooltipHeight / 2;
                    
                    // Keep within chart bounds
                    newTop = Math.max(10, Math.min(newTop, chartRect.height - tooltipHeight - 10));
                    
                    tooltip.style.top = newTop + 'px';
                }
            });
        }

        // Event listener for domain selector (will be set up after data loads)
        function setupDomainSelector() {
            const select = document.getElementById('domainSelect');
            select.addEventListener('change', function() {
                if (this.value && domains[this.value]) {
                    createChart(this.value, domains[this.value]);
                }
            });
        }

        // REVENUE LABEL CHANGE: Setup toggle event listener with dynamic update (no re-render)
        function setupRevenueToggle() {
            const toggle = document.getElementById('revenueLabelToggle');
            toggle.addEventListener('click', function() {
                showRevenueLabels = !showRevenueLabels;
                this.classList.toggle('inactive', !showRevenueLabels);
                
                // Update chart annotations dynamically without full re-render
                if (currentChart) {
                    currentChart.updateOptions({
                        annotations: {
                            points: showRevenueLabels ? currentAnnotations : []
                        }
                    }, false, false); // redrawPaths=false, animate=false for instant toggle
                }
            });
        }

        // CSV Loading Functions
        function parseCurrency(value) {
            if (!value || value === '' || value === '-') return 0;
            const cleaned = String(value).replace(/[$,]/g, '');
            return parseFloat(cleaned) || 0;
        }

        function parseNumber(value) {
            if (!value || value === '' || value === '-') return null;
            const cleaned = String(value).replace(/,/g, '');
            const num = parseInt(cleaned, 10);
            return isNaN(num) ? null : num;
        }

        function parseDate(dateStr) {
            // Convert "Jun 4 - 2025_1" to "Jun 4 2025" (remove dashes and _1/_2 suffixes)
            return dateStr.replace(/\s*-\s*/g, ' ').replace(/_\d+$/, '').trim();
        }

        function dateInRange(dateStr, startDate, endDate) {
            const date = parseDate(dateStr);
            const parts = date.split(' ');
            if (parts.length !== 3) return false;
            
            const [month, day, year] = parts;
            const dateObj = new Date(`${month} ${day}, ${year}`);
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            return dateObj >= start && dateObj <= end;
        }

        // List of domains to load
        const TARGET_DOMAINS = [
            'lyncconf.com',
            'betterthisworld.com',
            'etruesports.com',
            'activepropertycare.com',
            'seattlesportsonline.com',
            'healthsciencesforum.com',
            'famousparenting.com',
            'simplyseven.net',
            'decoratoradvice.com',
            'rapidhomedirect.com'
        ];

        async function loadRevenueCSV() {
            try {
                const response = await fetch('revenue-history.csv');
                if (!response.ok) throw new Error('Failed to load revenue CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const headers = parsed.meta.fields || [];
                const revenueByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    if (row) {
                        const monthlyRevenue = {};
                        headers.forEach(header => {
                            const monthMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/);
                            if (monthMatch) {
                                const [, month, year] = monthMatch;
                                const key = month + year;
                                const value = parseCurrency(row[header]);
                                // Include all values including $0 (but not empty/dash)
                                if (value >= 0 && row[header] && row[header] !== '-') {
                                    monthlyRevenue[key] = value;
                                }
                            }
                        });
                        revenueByDomain[domain] = monthlyRevenue;
                    } else {
                        revenueByDomain[domain] = {};
                    }
                });
                
                console.log('âœ… Revenue data loaded for domains:', Object.keys(revenueByDomain));
                return revenueByDomain;
            } catch (error) {
                console.error('Error loading revenue CSV:', error);
                throw error;
            }
        }

        async function loadDRHistoryCSV() {
            try {
                const response = await fetch('DR History.csv');
                if (!response.ok) throw new Error('Failed to load DR History CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const headers = parsed.meta.fields || [];
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const drByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const drDataMap = new Map();
                    
                    if (row) {
                        headers.forEach(header => {
                            // Match date format like "Jul 1 - 2024" or "Jan 20 - 2026"
                            const dateMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+)\s*-\s*(\d{4})$/);
                            if (dateMatch) {
                                const [, month, day, year] = dateMatch;
                                const dateStr = `${month} ${day} ${year}`;
                                const value = parseNumber(row[header]);
                                if (value !== null && value !== undefined) {
                                    // Only keep first occurrence of each date
                                    if (!drDataMap.has(dateStr)) {
                                        drDataMap.set(dateStr, value);
                                    }
                                }
                            }
                        });
                    }
                    
                    drByDomain[domain] = drDataMap;
                });
                
                console.log('âœ… DR History data loaded for domains:', Object.keys(drByDomain).map(d => `${d}: ${drByDomain[d].size} points`));
                return drByDomain;
            } catch (error) {
                console.error('Error loading DR History CSV:', error);
                throw error;
            }
        }

        async function loadAhrefsCSV() {
            try {
                const response = await fetch('ahrefs_organic_traffic_results.csv');
                if (!response.ok) throw new Error('Failed to load Ahrefs CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const ahrefsByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const ahrefsDataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.organic_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.organic_traffic);
                        if (value !== null && value !== undefined) {
                            ahrefsDataMap.set(dateStr, value);
                        }
                    });
                    
                    ahrefsByDomain[domain] = ahrefsDataMap;
                });
                
                console.log('âœ… Ahrefs data loaded for domains:', Object.keys(ahrefsByDomain).map(d => `${d}: ${ahrefsByDomain[d].size} points`));
                return ahrefsByDomain;
            } catch (error) {
                console.error('Error loading Ahrefs CSV:', error);
                throw error;
            }
        }

        async function loadTrafficCSV() {
            try {
                const response = await fetch('traffic-data.csv');
                if (!response.ok) throw new Error('Failed to load traffic CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: false,
                    transformHeader: (header) => header.trim()
                });
                
                const headers = parsed.meta.fields || [];
                const dateColumns = headers.slice(6); // Skip first 6 metadata columns
                
                // Build date info once (shared across all domains)
                const seenDates = new Map();
                dateColumns.forEach((header, idx) => {
                    if (!header || header.trim() === '') return;
                    const dateStr = parseDate(header);
                    if (!dateStr || dateStr === '') return;
                    if (!seenDates.has(dateStr)) {
                        seenDates.set(dateStr, { firstIndex: idx, secondIndex: -1, headers: [header] });
                    } else {
                        const entry = seenDates.get(dateStr);
                        if (entry.secondIndex === -1) entry.secondIndex = idx;
                        entry.headers.push(header);
                    }
                });
                
                let splitPoint = -1;
                seenDates.forEach((entry) => {
                    if (entry.secondIndex !== -1 && (splitPoint === -1 || entry.secondIndex < splitPoint)) {
                        splitPoint = entry.secondIndex;
                    }
                });
                
                const trafficByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    if (!row) {
                        trafficByDomain[domain] = { dates: [], ourData: [] };
                        return;
                    }
                    
                    const ourDataMap = new Map();
                    
                    dateColumns.forEach((header, idx) => {
                        if (!header || header.trim() === '') return;
                        
                        const suffixMatch = header.match(/_(\d+)$/);
                        const hasSuffix = suffixMatch !== null;
                        const headerForDate = hasSuffix ? header.replace(/_(\d+)$/, '') : header;
                        const dateStr = parseDate(headerForDate);
                        if (!dateStr || dateStr === '') return;
                        
                        const parts = dateStr.split(' ');
                        if (parts.length !== 3) return;
                        
                        const [month, day, year] = parts;
                        const dateObj = new Date(`${month} ${day}, ${year}`);
                        if (isNaN(dateObj.getTime())) return;
                        
                        const value = parseNumber(row[header]);
                        
                        // Only use first occurrence (our data), skip duplicates
                        let isOurData = !hasSuffix;
                        if (!hasSuffix && splitPoint > 0 && idx >= splitPoint) {
                            const entry = seenDates.get(dateStr);
                            if (entry && entry.secondIndex !== -1 && idx >= entry.secondIndex) {
                                isOurData = false;
                            }
                        }
                        
                        if (isOurData && !ourDataMap.has(dateStr)) {
                            ourDataMap.set(dateStr, value);
                        }
                    });
                    
                    // Sort dates chronologically
                    const sortedDates = Array.from(ourDataMap.keys()).sort((a, b) => {
                        const parseD = (s) => {
                            const p = s.split(' ');
                            return new Date(`${p[0]} ${p[1]}, ${p[2]}`);
                        };
                        return parseD(a) - parseD(b);
                    });
                    
                    const sortedOurData = sortedDates.map(d => ourDataMap.get(d));
                    
                    trafficByDomain[domain] = { dates: sortedDates, ourData: sortedOurData };
                });
                
                console.log('âœ… Traffic data loaded for domains:', Object.keys(trafficByDomain).map(d => `${d}: ${trafficByDomain[d].dates.length} dates`));
                return trafficByDomain;
            } catch (error) {
                console.error('Error loading traffic CSV:', error);
                throw error;
            }
        }

        function initializeDashboard(data) {
            domains = data;
            
            // Populate dropdown
            const select = document.getElementById('domainSelect');
            select.innerHTML = '<option value="">Select Domain</option>';
            Object.keys(domains).forEach(domain => {
                const opt = document.createElement('option');
                opt.value = domain;
                opt.textContent = `${domains[domain].rank}. ${domain}`;
                select.appendChild(opt);
            });
            
            // Setup event listeners
            setupDomainSelector();
            setupRevenueToggle(); // REVENUE LABEL CHANGE
            
            // Auto-select first domain
            if (Object.keys(domains).length > 0) {
                select.value = Object.keys(domains)[0];
                createChart(Object.keys(domains)[0], domains[Object.keys(domains)[0]]);
            }
        }

        async function loadDataFromCSV() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const errorMsg = document.getElementById('error-message');
            const chartsEl = document.getElementById('charts');
            
            // Check if we're on file:// protocol (CSV won't work)
            const isFileProtocol = window.location.protocol === 'file:';
            
            if (isFileProtocol) {
                // Use fallback immediately for file:// protocol
                console.log('File protocol detected - using fallback data');
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
                return;
            }
            
            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                chartsEl.innerHTML = '';
                
                // Set timeout for CSV loading (5 seconds max)
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('CSV loading timeout')), 5000)
                );
                
                const [revenueByDomain, trafficByDomain, ahrefsByDomain, drByDomain] = await Promise.race([
                    Promise.all([loadRevenueCSV(), loadTrafficCSV(), loadAhrefsCSV(), loadDRHistoryCSV()]),
                    timeoutPromise
                ]);
                
                // Helper to sort dates
                const parseDateForSort = (dateStr) => {
                    const parts = dateStr.split(' ');
                    if (parts.length !== 3) return new Date(0);
                    const [month, day, year] = parts;
                    return new Date(`${month} ${day}, ${year}`);
                };
                
                // Build domains object for all target domains
                domains = {};
                
                TARGET_DOMAINS.forEach((domain, idx) => {
                    const trafficData = trafficByDomain[domain] || { dates: [], ourData: [] };
                    const ahrefsDataMap = ahrefsByDomain[domain] || new Map();
                    const revenueData = revenueByDomain[domain] || {};
                    const drDataMap = drByDomain[domain] || new Map();
                    
                    // Merge all dates from traffic, ahrefs, and DR
                    const allDatesSet = new Set();
                    trafficData.dates.forEach(d => allDatesSet.add(d));
                    ahrefsDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                    drDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                    
                    // Add revenue dates
                    Object.keys(revenueData).forEach(monthKey => {
                        const noSpaceMatch = monthKey.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{4})$/);
                        if (noSpaceMatch) {
                            const [, month, year] = noSpaceMatch;
                            allDatesSet.add(`${month} 1 ${year}`);
                        }
                    });
                    
                    // Sort dates
                    const allDates = Array.from(allDatesSet).sort((a, b) => parseDateForSort(a) - parseDateForSort(b));
                    
                    // Build arrays
                    const ourDataMap = new Map();
                    trafficData.dates.forEach((date, i) => ourDataMap.set(date, trafficData.ourData[i]));
                    
                    const mergedDates = [];
                    const mergedOurData = [];
                    const mergedAhrefsData = [];
                    const mergedDRData = [];
                    
                    allDates.forEach(dateStr => {
                        mergedDates.push(dateStr);
                        mergedOurData.push(ourDataMap.get(dateStr) || null);
                        mergedAhrefsData.push(ahrefsDataMap.get(dateStr) || null);
                        mergedDRData.push(drDataMap.get(dateStr) || null);
                    });
                    
                    domains[domain] = {
                        rank: idx + 1,
                        dates: mergedDates,
                        ourData: mergedOurData,
                        ahrefsData: mergedAhrefsData,
                        drData: mergedDRData,
                        monthlyRevenue: revenueData
                    };
                });
                
                console.log('âœ… Data merged for all domains:', Object.keys(domains).map(d => 
                    `${d}: ${domains[d].dates.length} dates, ${domains[d].ourData.filter(v => v !== null).length} traffic pts, ${domains[d].drData.filter(v => v !== null).length} DR pts`
                ));
                
                loadingEl.style.display = 'none';
                initializeDashboard(domains);
            } catch (error) {
                // Fallback to hardcoded data on any error
                console.warn('CSV loading failed, using fallback data:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
            }
        }

        // Initialize on page load - try CSV first, fallback to hardcoded
        loadDataFromCSV();
    </script>
</body>
</html>
