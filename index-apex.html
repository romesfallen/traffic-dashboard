<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="googlebot" content="noindex, nofollow">
    <title>Traffic Dashboard - Premium</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #333333;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: #666666;
            font-size: 14px;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        /* Searchable dropdown styles */
        .search-dropdown {
            position: relative;
            min-width: 280px;
        }

        .search-dropdown input {
            width: 100%;
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            cursor: text;
            transition: all 0.2s ease;
        }

        .search-dropdown input:hover {
            border-color: #f97316;
        }

        .search-dropdown input:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .search-dropdown input::placeholder {
            color: #999999;
        }

        .dropdown-list {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #cccccc;
            border-top: none;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .dropdown-list.open {
            display: block;
        }

        .dropdown-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333333;
            transition: background 0.15s ease;
        }

        .dropdown-item:hover {
            background: #f5f5f5;
        }

        .dropdown-item.selected {
            background: #fff7ed;
            color: #f97316;
            font-weight: 500;
        }

        .dropdown-item .rank {
            color: #999999;
            font-size: 12px;
            margin-right: 8px;
        }

        .no-results {
            padding: 12px 16px;
            color: #999999;
            font-size: 14px;
            text-align: center;
        }

        .dropdown-divider {
            padding: 8px 16px;
            font-size: 11px;
            color: #999999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #f9f9f9;
            border-top: 1px solid #eee;
            border-bottom: 1px solid #eee;
        }

        .dropdown-item.on-demand {
            color: #666666;
        }

        .dropdown-item.on-demand:hover {
            background: #f5f5f5;
        }

        .dropdown-item.highlighted {
            background: #f5f5f5;
        }

        .card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .stats-row {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #f5f5f5;
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666666;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        .stat-value.positive { color: #4ade80; }
        .stat-value.negative { color: #f87171; }
        .stat-value.neutral { color: #fbbf24; }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333333;
        }

        .chart-subtitle {
            font-size: 13px;
            color: #666666;
        }

        .chart-range-select {
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-range-select:hover {
            border-color: #f97316;
            background: #ffffff;
        }

        .chart-range-select:focus {
            outline: none;
            border-color: #f97316;
        }

        #chart-container {
            min-height: 400px;
        }

        .header-stats {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        /* REVENUE LABEL CHANGE: Toggle switch styles */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333333;
        }

        /* View selector toggle group */
        .view-toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333333;
        }

        .view-toggle-group span {
            margin-right: 4px;
        }

        .view-btn {
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            color: #666666;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-btn:hover {
            border-color: #f97316;
            color: #f97316;
        }

        .view-btn.active {
            background: #f97316;
            border-color: #f97316;
            color: #ffffff;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            background: #cccccc;
            border-radius: 11px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .toggle-switch.active {
            background: #10b981;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .toggle-switch.active::after {
            transform: translateX(18px);
        }

        /* Centered domain title */
        .domain-title-centered {
            text-align: center;
            font-size: 22px;
            font-weight: 600;
            color: #333333;
            margin-bottom: 8px;
        }

        /* Ahrefs link icon */
        .ahrefs-link {
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
            vertical-align: middle;
        }

        .ahrefs-link img {
            width: 22px;
            height: 22px;
            opacity: 0.85;
            transition: opacity 0.2s ease;
            border-radius: 4px;
        }

        .ahrefs-link:hover img {
            opacity: 1;
        }

        /* Copy domain button */
        .copy-domain-btn {
            display: inline-flex;
            align-items: center;
            margin-left: 8px;
            vertical-align: middle;
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
        }

        .copy-domain-btn img {
            width: 20px;
            height: 20px;
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }

        .copy-domain-btn:hover img {
            opacity: 0.8;
        }

        .copy-domain-btn.copied img {
            opacity: 1;
        }

        /* Agent and Niche meta row */
        .domain-meta {
            text-align: center;
            font-size: 13px;
            color: #666666;
            margin-bottom: 16px;
        }

        .domain-meta .meta-label {
            font-weight: 500;
            color: #999999;
            margin-right: 4px;
        }

        .domain-meta .meta-divider {
            margin: 0 12px;
            color: #cccccc;
        }

        .domain-meta .agent-link {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }

        .domain-meta .agent-link:hover {
            text-decoration: underline;
        }

        .domain-meta .niche-link {
            color: #3b82f6;
            text-decoration: none;
            font-weight: 500;
        }

        .domain-meta .niche-link:hover {
            text-decoration: underline;
        }

        /* Revenue ranking bubbles */
        .ranking-bubbles {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .ranking-bubble {
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 12px 16px;
            min-width: 140px;
        }

        .ranking-bubble .rank-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .ranking-bubble .rank-number {
            font-weight: 700;
            font-size: 16px;
            color: #f97316;
        }

        .ranking-bubble .rank-label {
            color: #666666;
            font-size: 12px;
        }

        .ranking-bubble .rank-value {
            font-weight: 600;
            font-size: 14px;
            color: #333333;
        }

        .ranking-bubble .rank-pct {
            font-size: 12px;
            color: #10b981;
            font-weight: 500;
        }

        .ranking-bubble .rank-label-only {
            color: #666666;
            font-size: 12px;
        }

        /* Nav link - vertically centered */
        .nav-link {
            display: inline-flex;
            align-items: center;
            color: #f97316;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            margin-left: 16px;
            height: 44px;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        /* User info and sign out */
        .user-bar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            font-size: 13px;
            margin-bottom: 16px;
            color: #666;
        }

        .user-bar .user-email {
            color: #666;
        }

        .user-bar .sign-out {
            color: #f97316;
            text-decoration: none;
            font-weight: 500;
        }

        .user-bar .sign-out:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body style="visibility: hidden;">
    <div class="user-bar" id="userBar" style="display: none;">
        <span class="user-email" id="userEmail"></span>
        <a href="/api/auth/logout" class="sign-out">Sign Out</a>
    </div>
    <div class="header">
        <h1>Traffic Comparison Dashboard</h1>
        <p>Our Data vs Ahrefs â€” All Available Data</p>
    </div>

    <!-- REVENUE LABEL CHANGE: Toggle for revenue labels -->
    <div class="header-stats">
        <div class="toggle-container">
            <span>Revenue Labels</span>
            <div class="toggle-switch active" id="revenueLabelToggle"></div>
        </div>
        <div class="view-toggle-group">
            <span>Traffic View:</span>
            <button class="view-btn active" data-view="monthly" id="viewMonthly">Monthly</button>
            <button class="view-btn" data-view="average" id="viewAverage">Average</button>
            <button class="view-btn" data-view="both" id="viewBoth">Both</button>
        </div>
    </div>

    <div class="controls">
        <div class="search-dropdown" id="domainDropdown">
            <input type="text" id="domainSearch" placeholder="Search domains..." autocomplete="off">
            <div class="dropdown-list" id="dropdownList"></div>
        </div>
        <a href="leaderboard.html" class="nav-link">View Leaderboard â†’</a>
    </div>

    <div id="charts"></div>
    <div id="loading" style="display: none; text-align: center; padding: 40px; color: #666666;">
        <div style="font-size: 16px; margin-bottom: 12px;">Loading data...</div>
        <div style="font-size: 13px; color: #999999;">Parsing CSV files</div>
    </div>
    <div id="error" style="display: none; text-align: center; padding: 40px;">
        <div style="background: #fee; border: 1px solid #fcc; border-radius: 12px; padding: 24px; color: #c33;">
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Data</div>
            <div style="font-size: 13px;" id="error-message"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        let domains = {};
        
        // REVENUE LABEL CHANGE: Track toggle state, chart instance, and annotations for dynamic update
        let showRevenueLabels = true;
        let currentChart = null;
        let currentAnnotations = [];
        
        // VIEW TOGGLE: Track current view mode (monthly, average, both)
        let currentView = 'monthly';
        let currentDomainData = null;
        let currentDomainName = null;
        
        // Fallback hardcoded data (used if CSV loading fails or for file:// protocol)
        const fallbackData = {
            "lyncconf.com": {
                "rank": 1,
                "dates": ["Jun 4 2025", "Jun 6 2025", "Jun 9 2025", "Jun 11 2025", "Jun 13 2025", "Jun 15 2025", "Jun 16 2025", "Jun 17 2025", "Jun 18 2025", "Jun 19 2025", "Jun 20 2025", "Jun 21 2025", "Jun 22 2025", "Jun 23 2025", "Jun 24 2025", "Jun 25 2025", "Jun 26 2025", "Jun 27 2025", "Jun 28 2025", "Jun 29 2025", "Jun 30 2025", "Jul 1 2025", "Jul 2 2025", "Jul 3 2025", "Jul 4 2025", "Jul 5 2025", "Jul 6 2025", "Jul 7 2025", "Jul 8 2025", "Jul 9 2025", "Jul 10 2025", "Jul 11 2025", "Jul 12 2025", "Jul 13 2025", "Jul 14 2025", "Jul 15 2025", "Jul 16 2025", "Jul 17 2025", "Jul 18 2025", "Jul 19 2025", "Jul 20 2025", "Jul 21 2025", "Jul 22 2025", "Jul 23 2025", "Jul 24 2025", "Jul 25 2025", "Jul 26 2025", "Jul 27 2025", "Jul 28 2025", "Jul 29 2025", "Jul 30 2025", "Jul 31 2025", "Aug 1 2025", "Aug 2 2025", "Aug 3 2025", "Aug 4 2025", "Aug 5 2025", "Aug 6 2025", "Aug 7 2025", "Aug 8 2025", "Aug 9 2025", "Aug 10 2025", "Aug 11 2025", "Aug 12 2025", "Aug 13 2025", "Aug 14 2025", "Aug 15 2025", "Aug 16 2025", "Aug 17 2025", "Aug 18 2025", "Aug 19 2025", "Aug 20 2025", "Aug 21 2025", "Aug 22 2025", "Aug 23 2025", "Aug 24 2025", "Aug 25 2025", "Aug 26 2025", "Aug 27 2025", "Aug 28 2025", "Aug 29 2025", "Aug 30 2025", "Aug 31 2025", "Sep 1 2025", "Sep 2 2025", "Sep 3 2025", "Sep 4 2025", "Sep 5 2025", "Sep 6 2025", "Sep 7 2025", "Sep 8 2025", "Sep 9 2025", "Sep 10 2025", "Sep 11 2025", "Sep 12 2025", "Sep 13 2025", "Sep 14 2025", "Sep 15 2025", "Sep 16 2025", "Sep 17 2025", "Sep 18 2025", "Sep 19 2025", "Sep 20 2025", "Sep 21 2025", "Sep 22 2025", "Sep 23 2025", "Sep 24 2025", "Sep 25 2025", "Sep 26 2025", "Sep 27 2025", "Sep 28 2025", "Sep 29 2025", "Sep 30 2025", "Oct 1 2025", "Oct 2 2025", "Oct 3 2025", "Oct 4 2025", "Oct 5 2025", "Oct 6 2025", "Oct 7 2025", "Oct 8 2025", "Oct 9 2025", "Oct 10 2025", "Oct 11 2025", "Oct 12 2025", "Oct 13 2025", "Oct 14 2025", "Oct 15 2025", "Oct 16 2025", "Oct 17 2025", "Oct 18 2025", "Oct 19 2025", "Oct 20 2025", "Oct 21 2025", "Oct 22 2025", "Oct 23 2025", "Oct 24 2025", "Oct 25 2025", "Oct 26 2025", "Oct 27 2025", "Oct 28 2025", "Oct 29 2025", "Oct 30 2025", "Oct 31 2025", "Nov 1 2025", "Nov 2 2025", "Nov 3 2025", "Nov 4 2025", "Nov 5 2025", "Nov 6 2025", "Nov 7 2025", "Nov 8 2025", "Nov 9 2025", "Nov 10 2025", "Nov 11 2025", "Nov 12 2025", "Nov 13 2025", "Nov 14 2025", "Nov 15 2025", "Nov 16 2025", "Nov 17 2025", "Nov 18 2025", "Nov 19 2025", "Nov 20 2025", "Nov 21 2025", "Nov 22 2025", "Nov 23 2025", "Nov 24 2025", "Nov 25 2025", "Nov 26 2025", "Nov 27 2025", "Nov 28 2025", "Nov 29 2025", "Nov 30 2025", "Dec 1 2025", "Dec 2 2025", "Dec 3 2025", "Dec 4 2025", "Dec 5 2025", "Dec 6 2025", "Dec 7 2025", "Dec 8 2025", "Dec 9 2025", "Dec 10 2025", "Dec 11 2025", "Dec 12 2025", "Dec 13 2025", "Dec 14 2025", "Dec 15 2025", "Dec 16 2025", "Dec 17 2025", "Dec 18 2025", "Dec 19 2025", "Dec 20 2025", "Dec 21 2025", "Dec 22 2025", "Dec 23 2025", "Dec 24 2025", "Dec 25 2025", "Dec 26 2025", "Dec 27 2025", "Dec 28 2025", "Dec 29 2025", "Dec 30 2025", "Dec 31 2025", "Jan 1 2026", "Jan 2 2026", "Jan 3 2026", "Jan 4 2026", "Jan 5 2026", "Jan 6 2026", "Jan 7 2026", "Jan 8 2026", "Jan 9 2026", "Jan 10 2026", "Jan 11 2026", "Jan 12 2026", "Jan 13 2026"],
                "ourData": [21181, 12214, 14683, 14853, 14853, 15828, 16243, 15436, 14741, 14591, 14727, 13648, 13652, 13630, 12950, 12785, 12250, 12168, 12758, 14113, 13908, 14377, 15564, 15544, 31400, 18697, 17470, 17697, 17702, 17436, 17045, null, null, null, 16256, 15751, 16753, 16786, 18064, 18444, 18560, 18826, 18574, 17890, null, 17453, 17140, 17515, 17472, 17966, 17692, 17796, 17788, 17691, 17966, 18013, 17807, 18917, 18062, 19593, 19893, 19857, 20241, 21025, 20957, 20979, 20757, 21519, 21324, 21689, 21238, 22351, 22236, 22078, 22354, 22372, 22572, 22134, 25845, 25669, 25275, 25641, 25896, 27240, 26132, 25311, 27678, 26710, 22632, 22060, 21772, 20044, 19439, 20014, 20337, 20468, 22754, 22839, 22863, 22027, 23249, 23045, 20593, 20627, 19835, 19944, 20549, 22075, 22146, 21869, 22935, 22359, 21876, 21857, 22162, 21277, 20967, 20787, 21752, 21080, 21134, 35709, 34312, 39097, 38726, 38991, 38769, 38588, 38377, 42276, 41954, 41584, 42779, 42335, 41994, 41333, 41222, 41196, 41253, 41331, 40501, 40914, 39037, 36227, 35709, 36243, 37719, 37708, 37206, 37153, 36398, 35574, 34636, 34273, 33938, 33092, 33291, 37877, 37846, 40497, 41423, 37901, 37756, 34484, 32813, 32759, 31730, 31411, 31133, 35860, 35727, 35466, 35534, 33597, 33725, 33969, 33876, 33239, 29435, 29435, 29435, 29499, 29318, 29332, 29060, 29056, 33879, 32360, 31831, 32154, 31830, 32360, 32273, 30332, 26822, 25631, 25645, 27155, 26979, 27054, 28928, 28757, 29755, 29266, 29757, 29253, 29255, 33132, 33346, 33206, 33196, 31908, 31758, 31450, 31720, 31528, 31688, 33221],
                "ahrefsData": [17528, 17527, 17186, 17523, 18024, 17792, 17977, 17593, 17404, 17257, 17189, 17204, 17218, 17231, 16822, 16528, 16154, 16641, 16946, 17137, 17012, 17271, 18026, 17927, 18299, 17851, 17701, 17802, 17731, 17337, 16765, 16442, 15874, 15386, 15074, 14772, 14817, 14566, 14575, 14401, 14444, 14705, 14532, 14530, 14220, 14379, 14276, 14016, 13828, 14019, 14058, 14039, 14200, 14291, 14674, 15683, 16767, 16973, 16861, 16951, 17571, 17970, 17935, 18359, 18498, 17629, 18192, 18461, 18206, 18342, 18807, 18556, 18453, 18828, 18855, 18331, 18499, 18902, 19215, 19260, 18655, 18479, 19183, 26261, 27209, 31515, 32057, 37858, 39789, 41136, 43910, 43490, 44102, 44949, 49039, 53254, 54810, 55483, 55860, 59064, 59505, 60087, 59502, 59714, 61523, 62437, 66084, 66295, 65929, 66803, 67012, 66667, 65457, 65294, 77416, 78362, 80187, 82054, 82102, 83507, 85663, 85012, 84857, 87302, 86783, 90198, 89738, 89679, 89303, 89287, 88653, 89210, 89792, 89049, 89206, 89521, 89308, 89491, 89589, 89437, 90023, 87930, 87415, 87761, 87824, 83780, 80815, 81108, 81137, 80606, 78352, 76677, 75936, 74946, 75697, 75902, 72775, 72194, 71603, 72297, 63810, 64307, 62909, 61219, 59119, 59079, 59178, 58832, 58824, 58272, 58092, 57793, 56335, 55104, 54808, 54797, 52267, 49815, 49815, 49815, 49804, 49030, 47758, 47372, 47377, 47392, 44775, 43091, 44252, 43685, 44094, 44010, 41503, 39458, 37858, 37163, 37451, 37281, 37832, 37197, 37162, 36846, 35246, 34897, 34439, 34555, 34444, 34729, 34686, 34582, 33974, 33946, 33551, 33270, 33193, 33178, 33322, 33180],
                "drData": [67, 67, 67, 68, 68, 69, 70, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 71, 72, 72, 72, 71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 70, 70, 70, 70, 70, 70, 70, 70, 70, 69, 70, 70, 70, 69, 69, 69, 69, 69, 69, 68, 68, 68, 68, 68, 68, 68, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71],
                "internalAvgData": [],
                "ahrefsAvgData": [],
                "ourChange": "+56.8%",
                "ahrefsChange": "+89.3%",
                "revenueRankings": {
                    "lifetime": 1,
                    "last3Month": 1,
                    "currentMonth": 1,
                    "lifetimeValue": 351788,
                    "last3MonthValue": 19585,
                    "currentMonthValue": 3630,
                    "lifetimePct": "100.0",
                    "last3MonthPct": "100.0",
                    "currentMonthPct": "100.0"
                }
            }
        };

        function getStatClass(value) {
            const num = parseFloat(value);
            if (num > 5) return 'positive';
            if (num < -5) return 'negative';
            return 'neutral';
        }

        // Linear interpolation for missing data
        function interpolateData(arr) {
            const real = [...arr];
            const estimated = new Array(arr.length).fill(null);
            const isEstimated = new Array(arr.length).fill(false);
            
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === null) {
                    let prevIdx = i - 1;
                    while (prevIdx >= 0 && arr[prevIdx] === null) prevIdx--;
                    
                    let nextIdx = i + 1;
                    while (nextIdx < arr.length && arr[nextIdx] === null) nextIdx++;
                    
                    if (prevIdx >= 0 && nextIdx < arr.length) {
                        const prevVal = arr[prevIdx];
                        const nextVal = arr[nextIdx];
                        const steps = nextIdx - prevIdx;
                        const step = (nextVal - prevVal) / steps;
                        const interpolated = Math.round(prevVal + step * (i - prevIdx));
                        
                        real[i] = interpolated;
                        estimated[i] = interpolated;
                        isEstimated[i] = true;
                    }
                }
            }
            
            return { real, estimated, isEstimated };
        }

        // Calculate x-axis range for initial zoom (returns min/max timestamps)
        // Returns null for 'all' to show full range
        function getDateRangeBounds(data, days) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Helper to parse date string to timestamp
            function parseDateStr(dateStr) {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return null;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return null;
                return new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
            }
            
            if (days === 'all' || !data.dates || data.dates.length === 0) {
                return { min: undefined, max: undefined };
            }
            
            // Get the last date's timestamp for max bound
            const lastDate = data.dates[data.dates.length - 1];
            const maxTimestamp = parseDateStr(lastDate);
            
            // Special case: From December 2024
            if (days === 'dec2024') {
                const startDate = new Date(2024, 11, 1); // Dec 1, 2024
                return { min: startDate.getTime(), max: maxTimestamp };
            }
            
            // For numeric days (7, 30, 90, etc.), calculate start from end
            const numDays = parseInt(days);
            if (isNaN(numDays) || !maxTimestamp) {
                return { min: undefined, max: undefined };
            }
            
            const minTimestamp = maxTimestamp - (numDays * 24 * 60 * 60 * 1000);
            return { min: minTimestamp, max: maxTimestamp };
        }
        
        // Filter data by date range (kept for backwards compatibility but returns all data)
        function filterByDateRange(data, days) {
            // Always return ALL data - zoom range is controlled by xaxis min/max
            return {
                dates: data.dates,
                ourData: data.ourData,
                ahrefsData: data.ahrefsData,
                drData: data.drData || []
            };
        }

        // REVENUE LABEL CHANGE: Modified to also return annotation data for labels
        // Generate monthly revenue with strict normalization and timestamp-based stepped blocks
        function generateMonthlyRevenue(dates, monthlyRevenueData = null) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Use CSV data if provided, otherwise use default
            const monthRevenue = monthlyRevenueData || {
                'Jun2025': 100, 'Jul2025': 200, 'Aug2025': 300, 'Sep2025': 400,
                'Oct2025': 500, 'Nov2025': 600, 'Dec2025': 700, 'Jan2026': 800
            };
            
            // Helper: Parse "Jan 1 2024" to timestamp
            function parseDateToTimestamp(dateStr) {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return null;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return null;
                return new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
            }
            
            // STEP 1: Normalize & De-Duplicate by YYYY-MM
            // Create a Map keyed by YYYY-MM, keeping latest value per month
            const normalizedMap = new Map();
            
            // First, extract unique months from dates array
            dates.forEach(dateStr => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return;
                
                // Key: YYYY-MM format for sorting
                const key = `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
                // Revenue key format: "Jun2025"
                const revenueKey = month + year;
                const revenueValue = monthRevenue[revenueKey] || 0;
                
                // Keep latest value (overwrites if exists)
                normalizedMap.set(key, {
                    year: parseInt(year),
                    monthIndex: monthIndex,
                    month: month,
                    revenue: revenueValue
                });
            });
            
            // Sort keys chronologically
            const sortedKeys = Array.from(normalizedMap.keys()).sort();
            
            // STEP 2: Generate Stepped Area Blocks (3 points per month)
            const revenuePoints = [];
            
            // REVENUE LABEL CHANGE: Also build annotations array for point annotations
            const revenueAnnotations = [];
            
            sortedKeys.forEach(key => {
                const info = normalizedMap.get(key);
                const revenue = info.revenue;
                
                // Start Date: 1st of the month
                const startDate = new Date(info.year, info.monthIndex, 1);
                
                // End Date: Start + 25 days
                const endDate = new Date(info.year, info.monthIndex, 26); // Day 26
                
                // Cut Date: Start + 26 days (creates sharp drop)
                const cutDate = new Date(info.year, info.monthIndex, 27); // Day 27
                
                // Push 3 points for stepped area
                revenuePoints.push({ x: startDate.getTime(), y: revenue });
                revenuePoints.push({ x: endDate.getTime(), y: revenue });
                revenuePoints.push({ x: cutDate.getTime(), y: 0 });
                
                // REVENUE LABEL CHANGE: Create point annotation at center of bar (day 13)
                const midDate = new Date(info.year, info.monthIndex, 13);
                // Always add annotation for month label positioning, include revenue if > 0
                revenueAnnotations.push({
                    x: midDate.getTime(),
                    y: revenue,
                    label: revenue > 0 ? '$' + revenue.toLocaleString() : '',
                    month: info.month,
                    year: info.year,
                    monthLabel: info.month + ' ' + info.year
                });
            });
            
            // SAFETY CHECK: Sort by timestamp
            revenuePoints.sort((a, b) => a.x - b.x);
            
            // Log for verification
            console.log('ðŸ“Š Revenue Data Processed:', {
                uniqueMonths: sortedKeys.length,
                totalPoints: revenuePoints.length,
                expectedPoints: sortedKeys.length * 3,
                firstMonth: sortedKeys[0],
                lastMonth: sortedKeys[sortedKeys.length - 1],
                samplePoints: revenuePoints.slice(0, 6),
                annotations: revenueAnnotations.length // REVENUE LABEL CHANGE
            });
            
            // Also generate categories array for x-axis labels (mid-month positioned)
            const categories = new Array(dates.length).fill(' ');
            
            // Find mid-month indices for labels
            const monthIndices = {};
            dates.forEach((dateStr, idx) => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                const [month, day, year] = parts;
                const key = month + year;
                if (!monthIndices[key]) {
                    monthIndices[key] = { firstIdx: idx, lastIdx: idx, month, year };
                } else {
                    monthIndices[key].lastIdx = idx;
                }
            });
            
            Object.entries(monthIndices).forEach(([key, info]) => {
                const midIdx = Math.floor((info.firstIdx + info.lastIdx) / 2);
                categories[midIdx] = info.month + ' ' + info.year;
            });
            
            // REVENUE LABEL CHANGE: Return annotations array as well
            return { revenuePoints, categories, revenueAnnotations };
        }

        // Calculate change percentage for filtered data
        function calcChange(arr) {
            const validData = arr.filter(v => v !== null && v !== undefined);
            if (validData.length < 2) return 'N/A';
            const first = validData[0];
            const last = validData[validData.length - 1];
            const change = ((last - first) / first * 100).toFixed(1);
            return (change >= 0 ? '+' : '') + change + '%';
        }

        function createChart(domain, data, dateRange = 'dec2024') {
            // REVENUE LABEL CHANGE: Destroy previous chart if exists
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            // VIEW TOGGLE: Store current domain info for view toggles
            currentDomainData = data;
            currentDomainName = domain;
            
            const chartsDiv = document.getElementById('charts');
            chartsDiv.innerHTML = '';

            const filtered = filterByDateRange(data, dateRange);

            const card = document.createElement('div');
            card.className = 'card';

            // Get revenue rankings (with fallback defaults)
            const rankings = data.revenueRankings || { 
                lifetime: '-', last3Month: '-', currentMonth: '-',
                lifetimeValue: 0, last3MonthValue: 0, currentMonthValue: 0,
                lifetimePct: 0, last3MonthPct: 0, currentMonthPct: 0
            };
            
            // Format currency
            const formatCurrency = (val) => '$' + Math.round(val).toLocaleString();
            
            // Get agent and niche info
            const agentNicheInfo = agentNicheData[domain.toLowerCase()] || { agent: '', niche: '' };
            const agentName = agentNicheInfo.agent || 'Unknown';
            const nicheString = agentNicheInfo.niche || '';
            
            // Build niche links HTML (split by comma, each as separate link)
            let nicheLinksHtml = '';
            if (nicheString) {
                const niches = nicheString.split(',').map(n => n.trim()).filter(n => n);
                nicheLinksHtml = niches.map((niche, idx) => {
                    const separator = idx < niches.length - 1 ? ', ' : '';
                    return `<a href="niche.html?niche=${encodeURIComponent(niche)}" class="niche-link">${niche}</a>${separator}`;
                }).join('');
            } else {
                nicheLinksHtml = '<span style="color: #999;">Unknown</span>';
            }
            
            card.innerHTML = `
                <div class="domain-title-centered">${domain}<a href="${getAhrefsUrl(domain)}" target="_blank" class="ahrefs-link" title="View in Ahrefs"><img src="ahrefs-icon.svg" alt="Ahrefs"></a><button class="copy-domain-btn" onclick="copyDomain('${domain}', event)" title="Copy domain"><img src="copy-icon.svg" alt="Copy"></button></div>
                <div class="domain-meta">
                    <span class="meta-label">Agent:</span>
                    <a href="agent.html?agent=${encodeURIComponent(agentName)}" class="agent-link">${agentName}</a>
                    <span class="meta-divider">|</span>
                    <span class="meta-label">Niche:</span>
                    ${nicheLinksHtml}
                </div>
                <div class="ranking-bubbles">
                    <div class="ranking-bubble">
                        <div class="rank-header">
                            <span class="rank-number">#${rankings.lifetime}</span>
                            <span class="rank-label">Lifetime Revenue</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.lifetimeValue)}</div>
                        <div class="rank-pct">${rankings.lifetimePct}% of portfolio</div>
                    </div>
                    <div class="ranking-bubble">
                        <div class="rank-header">
                            <span class="rank-number">#${rankings.last3Month}</span>
                            <span class="rank-label">Last 3 Months</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.last3MonthValue)}</div>
                        <div class="rank-pct">${rankings.last3MonthPct}% of portfolio</div>
                    </div>
                    <div class="ranking-bubble">
                        <div class="rank-header">
                            <span class="rank-number">#${rankings.currentMonth}</span>
                            <span class="rank-label">Current Month</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.currentMonthValue)}</div>
                        <div class="rank-pct">${rankings.currentMonthPct}% of portfolio</div>
                    </div>
                    <div class="ranking-bubble avg-bubble">
                        <div class="rank-header">
                            <span class="rank-label-only">Avg Last 3 Months</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.last3MonthValue / 3)}</div>
                    </div>
                </div>
                <div class="chart-header">
                    <div></div>
                    <select class="chart-range-select" id="chartDateRange">
                        <option value="7" ${dateRange === '7' ? 'selected' : ''}>Last 7 days</option>
                        <option value="30" ${dateRange === '30' ? 'selected' : ''}>Last month</option>
                        <option value="90" ${dateRange === '90' ? 'selected' : ''}>Last 3 months</option>
                        <option value="180" ${dateRange === '180' ? 'selected' : ''}>Last 6 months</option>
                        <option value="365" ${dateRange === '365' ? 'selected' : ''}>Last year</option>
                        <option value="dec2024" ${dateRange === 'dec2024' ? 'selected' : ''}>From Dec 2024</option>
                        <option value="all" ${dateRange === 'all' ? 'selected' : ''}>All time</option>
                    </select>
                </div>
                <div id="apex-chart"></div>
            `;
            chartsDiv.appendChild(card);

            document.getElementById('chartDateRange').addEventListener('change', function() {
                createChart(domain, data, this.value);
            });

            const ourProcessed = interpolateData(filtered.ourData);
            const ahrefsProcessed = interpolateData(filtered.ahrefsData);
            const drProcessed = interpolateData(filtered.drData || []);
            const internalAvgProcessed = interpolateData(data.internalAvgData || []);
            const ahrefsAvgProcessed = interpolateData(data.ahrefsAvgData || []);
            const revenueResult = generateMonthlyRevenue(filtered.dates, data.monthlyRevenue);
            
            // Get x-axis bounds for initial zoom (allows zooming out beyond this range)
            const xAxisBounds = getDateRangeBounds(data, dateRange);
            
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Convert traffic data to timestamp-based {x, y} format
            function convertToTimestampData(dates, values) {
                return dates.map((dateStr, idx) => {
                    const parts = dateStr.split(' ');
                    if (parts.length !== 3) return null;
                    const [month, day, year] = parts;
                    const monthIndex = monthNames.indexOf(month);
                    if (monthIndex === -1) return null;
                    const timestamp = new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
                    return { x: timestamp, y: values[idx] };
                }).filter(p => p !== null);
            }
            
            const ourDataPoints = convertToTimestampData(filtered.dates, ourProcessed.real);
            const ahrefsDataPoints = convertToTimestampData(filtered.dates, ahrefsProcessed.real);
            const drDataPoints = convertToTimestampData(filtered.dates, drProcessed.real);
            const internalAvgDataPoints = convertToTimestampData(filtered.dates, internalAvgProcessed.real);
            const ahrefsAvgDataPoints = convertToTimestampData(filtered.dates, ahrefsAvgProcessed.real);
            const revenuePoints = revenueResult.revenuePoints;
            
            // Calculate max revenue for "bottom-third" axis scaling
            const maxRevenue = Math.max(...revenuePoints.map(p => p.y || 0), 1);
            const revenueAxisMax = maxRevenue * 3;
            
            // REVENUE LABEL CHANGE: Build point annotations and store globally for toggle
            // Use uniform Y position for all labels so they appear at same height near bottom of bars
            const labelYPosition = maxRevenue * 0.025; // Position all labels very close to the x-axis
            
            currentAnnotations = revenueResult.revenueAnnotations.map(ann => ({
                x: ann.x,
                y: labelYPosition, // Fixed uniform height for all labels
                yAxisIndex: 2, // Revenue y-axis
                seriesIndex: 2, // Revenue series
                marker: {
                    size: 0 // Hide the marker dot
                },
                label: {
                    borderColor: 'transparent',
                    borderWidth: 0,
                    text: ann.label,
                    style: {
                        background: 'transparent',
                        color: '#047857', // Dark green for visibility
                        fontSize: '10px',
                        fontWeight: 600,
                        fontFamily: 'Inter, sans-serif',
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    offsetY: 0, // No additional offset needed with fixed position
                    offsetX: 0
                }
            }));
            
            // Use annotations based on current toggle state
            const pointAnnotations = showRevenueLabels ? currentAnnotations : [];

            // VIEW TOGGLE: Determine which series to show based on currentView
            const showMonthly = currentView === 'monthly' || currentView === 'both';
            const showAverage = currentView === 'average' || currentView === 'both';
            
            // Build series array based on view
            const allSeries = [];
            
            // Monthly series (indices 0, 1)
            if (showMonthly) {
                allSeries.push({
                    name: 'Internal Monthly Traffic',
                    type: 'area',
                    data: ourDataPoints
                });
                allSeries.push({
                    name: 'Ahrefs Monthly Traffic',
                    type: 'area',
                    data: ahrefsDataPoints
                });
            }
            
            // Average series (indices 2, 3 when monthly hidden, or 4, 5 when both shown)
            if (showAverage) {
                allSeries.push({
                    name: 'Internal Average Traffic',
                    type: 'area',
                    data: internalAvgDataPoints
                });
                allSeries.push({
                    name: 'Ahrefs Average Traffic',
                    type: 'area',
                    data: ahrefsAvgDataPoints
                });
            }
            
            // Revenue always shown
            allSeries.push({
                name: 'Revenue',
                type: 'area',
                data: revenuePoints
            });
            
            // DR always shown
            allSeries.push({
                name: 'DR',
                type: 'line',
                data: drDataPoints
            });
            
            // Build colors array based on visible series
            const allColors = [];
            if (showMonthly) {
                allColors.push('#f97316'); // Internal Monthly - Orange
                allColors.push('#3b82f6'); // Ahrefs Monthly - Blue
            }
            if (showAverage) {
                allColors.push('#ef4444'); // Internal Average - Red
                allColors.push('#06b6d4'); // Ahrefs Average - Cyan
            }
            allColors.push('#10b981'); // Revenue - Green
            allColors.push('#a855f7'); // DR - Purple
            
            // Build stroke config based on visible series
            const strokeCurve = [];
            const strokeWidth = [];
            const strokeDash = [];
            const fillOpacity = [];
            
            if (showMonthly) {
                strokeCurve.push('smooth', 'smooth');
                strokeWidth.push(2, 2);
                strokeDash.push(0, 0);
                fillOpacity.push(0, 0);
            }
            if (showAverage) {
                strokeCurve.push('smooth', 'smooth');
                strokeWidth.push(2, 2);
                strokeDash.push(0, 0); // Solid lines for average (matches monthly)
                fillOpacity.push(0, 0);
            }
            // Revenue
            strokeCurve.push('stepline');
            strokeWidth.push(0);
            strokeDash.push(0);
            fillOpacity.push(0.25);
            // DR
            strokeCurve.push('straight');
            strokeWidth.push(3);
            strokeDash.push(6);
            fillOpacity.push(0);
            
            const options = {
                series: allSeries,
                chart: {
                    type: 'line',
                    height: 480,
                    background: 'transparent',
                    toolbar: { 
                        show: true, 
                        tools: { 
                            download: true, 
                            zoom: true, 
                            zoomin: true,
                            zoomout: true,
                            pan: true,
                            reset: true // Home icon to reset to initial zoom
                        }
                    },
                    zoom: {
                        enabled: true,
                        type: 'x', // Allow zooming on x-axis
                        autoScaleYaxis: true // Auto-adjust y-axis when zooming
                    },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    },
                    stacked: false
                },
                // REVENUE LABEL CHANGE: Add annotations section
                // Build xaxis annotations for centered month labels
                annotations: {
                    points: pointAnnotations,
                    xaxis: revenueResult.revenueAnnotations.map(ann => {
                        const isJanuary = ann.month === 'Jan';
                        return {
                            x: ann.x,
                            borderColor: 'transparent',
                            label: {
                                borderColor: 'transparent',
                                borderWidth: 0,
                                text: ann.monthLabel,
                                orientation: 'horizontal',
                                position: 'bottom',
                                style: {
                                    background: 'transparent',
                                    color: '#333333',
                                    fontSize: '11px',
                                    fontWeight: isJanuary ? 700 : 500, // Bold for January to mark year start
                                    fontFamily: 'Inter, sans-serif',
                                    padding: { left: 0, right: 0, top: 0, bottom: 0 }
                                },
                                offsetY: 20
                            }
                        };
                    })
                },
                colors: allColors,
                fill: {
                    type: allSeries.map(() => 'solid'),
                    opacity: fillOpacity
                },
                stroke: {
                    curve: strokeCurve,
                    width: strokeWidth,
                    dashArray: strokeDash
                },
                markers: {
                    size: allSeries.map((s, i) => s.name === 'DR' ? 2 : 0), // Small markers for DR only
                    hover: { size: 5 },
                    strokeWidth: 0
                },
                xaxis: {
                    type: 'datetime',
                    min: xAxisBounds.min, // Initial zoom start (undefined = auto)
                    max: xAxisBounds.max, // Initial zoom end (undefined = auto)
                    labels: {
                        show: false // Hide default labels - using centered xaxis annotations instead
                    },
                    axisBorder: { color: '#cccccc' },
                    axisTicks: { show: false },
                    crosshairs: {
                        show: true,
                        stroke: { color: '#999999', width: 1, dashArray: 3 }
                    },
                    tooltip: { enabled: true, format: 'dd MMM yyyy' }
                },
                yaxis: (() => {
                    // Build y-axis config dynamically based on visible series
                    const yaxisConfig = [];
                    
                    // First traffic series gets the main left axis
                    let firstTrafficAxis = true;
                    
                    if (showMonthly) {
                        // Internal Monthly Traffic - Left Axis (Primary)
                        yaxisConfig.push({
                            seriesName: 'Internal Monthly Traffic',
                            title: firstTrafficAxis ? {
                                text: 'Traffic',
                                style: { color: '#333333', fontSize: '12px' }
                            } : undefined,
                            show: firstTrafficAxis,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                        firstTrafficAxis = false;
                        
                        // Ahrefs Monthly - shares axis
                        yaxisConfig.push({
                            seriesName: 'Ahrefs Monthly Traffic',
                            show: false,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                    }
                    
                    if (showAverage) {
                        // Internal Average Traffic
                        yaxisConfig.push({
                            seriesName: 'Internal Average Traffic',
                            title: firstTrafficAxis ? {
                                text: 'Traffic',
                                style: { color: '#333333', fontSize: '12px' }
                            } : undefined,
                            show: firstTrafficAxis,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                        firstTrafficAxis = false;
                        
                        // Ahrefs Average - shares axis
                        yaxisConfig.push({
                            seriesName: 'Ahrefs Average Traffic',
                            show: false,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                    }
                    
                    // Revenue - Right Axis
                    yaxisConfig.push({
                        seriesName: 'Revenue',
                        opposite: true,
                        title: {
                            text: 'Revenue ($)',
                            style: { color: '#10b981', fontSize: '12px' }
                        },
                        labels: {
                            style: { colors: '#10b981' },
                            formatter: val => val ? '$' + val.toLocaleString() : ''
                        },
                        min: 0,
                        max: revenueAxisMax
                    });
                    
                    // DR - Right Axis B
                    yaxisConfig.push({
                        seriesName: 'DR',
                        opposite: true,
                        title: {
                            text: 'DR',
                            style: { color: '#a855f7', fontSize: '12px' },
                            offsetX: -10
                        },
                        labels: {
                            style: { colors: '#a855f7' },
                            formatter: val => val ? val.toFixed(0) : '',
                            offsetX: -10
                        },
                        min: 0,
                        max: 100,
                        tickAmount: 5,
                        axisBorder: {
                            show: true,
                            color: '#a855f7',
                            offsetX: -5
                        }
                    });
                    
                    return yaxisConfig;
                })(),
                grid: {
                    borderColor: '#e8e8e8',
                    strokeDashArray: 0,
                    padding: {
                        left: 20,
                        right: 40, // Extra space for DR axis
                        bottom: 15
                    }
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'left',
                    offsetY: 0,
                    labels: { colors: '#333333' },
                    markers: { width: 10, height: 10, radius: 10 }
                },
                tooltip: {
                    enabled: true,
                    shared: true,
                    intersect: false,
                    followCursor: true,
                    fixed: {
                        enabled: false
                    },
                    custom: function({ series, seriesIndex, dataPointIndex, w }) {
                        // Get the x value (timestamp) from the HOVERED series
                        const hoveredSeriesData = w.config.series[seriesIndex].data;
                        const hoveredPoint = hoveredSeriesData[dataPointIndex];
                        const xValue = hoveredPoint?.x;
                        
                        if (!xValue) return '';
                        
                        const date = new Date(xValue);
                        const dateStr = date.toLocaleDateString('en-GB', { 
                            day: 'numeric', 
                            month: 'short', 
                            year: 'numeric' 
                        });
                        
                        let html = '<div class="apexcharts-tooltip-custom" style="padding: 10px; background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.12);">';
                        html += '<div style="font-weight: 600; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #eee; color: #333;">' + dateStr + '</div>';
                        
                        // Loop through all visible series dynamically
                        const seriesCount = w.config.series.length;
                        const seriesColors = w.config.colors;
                        
                        for (let i = 0; i < seriesCount; i++) {
                            const seriesData = w.config.series[i].data;
                            const seriesName = w.config.series[i].name;
                            const seriesColor = seriesColors[i];
                            let value = null;
                            
                            // Find the closest point by timestamp
                            let closestDiff = Infinity;
                            const isRevenue = seriesName === 'Revenue';
                            const maxDiff = isRevenue ? 20 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000;
                            
                            for (let j = 0; j < seriesData.length; j++) {
                                const point = seriesData[j];
                                if (point && point.x !== undefined) {
                                    const diff = Math.abs(point.x - xValue);
                                    if (diff < closestDiff && diff <= maxDiff) {
                                        closestDiff = diff;
                                        value = point.y;
                                    }
                                }
                            }
                            
                            // Format value based on series type
                            let displayValue = 'â€”';
                            if (value !== null && value !== undefined) {
                                if (seriesName === 'Revenue') {
                                    displayValue = '$' + value.toLocaleString();
                                } else if (seriesName === 'DR') {
                                    displayValue = value.toFixed(0);
                                } else if (value !== 0) {
                                    displayValue = value.toLocaleString() + ' visits';
                                }
                            }
                            
                            // Skip if no data found
                            if (value === null) {
                                continue;
                            }
                            
                            html += '<div style="display: flex; align-items: center; padding: 4px 0;">';
                            html += '<span style="width: 10px; height: 10px; border-radius: 50%; background: ' + seriesColor + '; margin-right: 8px;"></span>';
                            html += '<span style="color: #666; min-width: 140px;">' + seriesName + ':</span>';
                            html += '<span style="font-weight: 600; color: #333; margin-left: auto;">' + displayValue + '</span>';
                            html += '</div>';
                        }
                        
                        html += '</div>';
                        return html;
                    }
                },
                dataLabels: { enabled: false }
            };

            const chart = new ApexCharts(document.querySelector('#apex-chart'), options);
            chart.render();
            
            // REVENUE LABEL CHANGE: Store chart instance for dynamic updates
            currentChart = chart;
            
            // Make tooltip follow cursor on Y axis
            const chartEl = document.querySelector('#apex-chart');
            chartEl.addEventListener('mousemove', function(e) {
                const tooltip = chartEl.querySelector('.apexcharts-tooltip');
                if (tooltip && tooltip.classList.contains('apexcharts-active')) {
                    const chartRect = chartEl.getBoundingClientRect();
                    const mouseY = e.clientY - chartRect.top;
                    const tooltipHeight = tooltip.offsetHeight;
                    
                    // Position tooltip near cursor Y, with some offset
                    let newTop = mouseY - tooltipHeight / 2;
                    
                    // Keep within chart bounds
                    newTop = Math.max(10, Math.min(newTop, chartRect.height - tooltipHeight - 10));
                    
                    tooltip.style.top = newTop + 'px';
                }
            });
        }

        // Searchable dropdown functionality
        let selectedDomain = null;
        
        function setupDomainSelector() {
            const input = document.getElementById('domainSearch');
            const dropdownList = document.getElementById('dropdownList');
            
            // Build dropdown items - show preloaded first, then on-demand
            function renderDropdown(filter = '') {
                const filterLower = filter.toLowerCase();
                
                // Preloaded domains (already in domains object)
                const preloaded = Object.keys(domains)
                    .filter(domain => domain.toLowerCase().includes(filterLower))
                    .sort((a, b) => domains[a].rank - domains[b].rank);
                
                // On-demand domains (in allAvailableDomains but not preloaded)
                const onDemand = Array.from(allAvailableDomains)
                    .filter(domain => 
                        domain.includes(filterLower) && 
                        !domains[domain] && 
                        !domains[domain.charAt(0).toUpperCase() + domain.slice(1)] // Handle case differences
                    )
                    .sort();
                
                if (preloaded.length === 0 && onDemand.length === 0) {
                    dropdownList.innerHTML = '<div class="no-results">No domains found</div>';
                } else {
                    let html = '';
                    
                    // Preloaded domains with rank
                    html += preloaded.map(domain => {
                        const isSelected = domain === selectedDomain;
                        return `<div class="dropdown-item${isSelected ? ' selected' : ''}" data-domain="${domain}">
                            <span class="rank">${domains[domain].rank}.</span>${domain}
                        </div>`;
                    }).join('');
                    
                    // On-demand domains (show only when filtering, max 50)
                    if (filterLower.length >= 2 && onDemand.length > 0) {
                        const limitedOnDemand = onDemand.slice(0, 50);
                        if (preloaded.length > 0) {
                            html += '<div class="dropdown-divider">Other domains (load on demand)</div>';
                        }
                        html += limitedOnDemand.map(domain => {
                            return `<div class="dropdown-item on-demand" data-domain="${domain}" data-ondemand="true">
                                <span class="rank" style="color: #999;">â€”</span>${domain}
                            </div>`;
                        }).join('');
                        if (onDemand.length > 50) {
                            html += `<div class="no-results" style="font-size: 11px;">...and ${onDemand.length - 50} more. Type more to filter.</div>`;
                        }
                    }
                    
                    dropdownList.innerHTML = html;
                }
            }
            
            // Show dropdown on focus - select all text and show full list
            input.addEventListener('focus', function() {
                this.select();
                renderDropdown('');
                dropdownList.classList.add('open');
            });
            
            // Filter on input
            input.addEventListener('input', function() {
                renderDropdown(this.value);
                dropdownList.classList.add('open');
            });
            
            // Handle item click
            dropdownList.addEventListener('click', async function(e) {
                const item = e.target.closest('.dropdown-item');
                if (item) {
                    const domain = item.dataset.domain;
                    const isOnDemand = item.dataset.ondemand === 'true';
                    
                    selectedDomain = domain;
                    input.value = domain;
                    dropdownList.classList.remove('open');
                    
                    if (isOnDemand) {
                        // Show loading state
                        const loadingEl = document.getElementById('loading');
                        loadingEl.style.display = 'block';
                        loadingEl.querySelector('div').textContent = `Loading ${domain}...`;
                        
                        const domainData = await loadDomainOnDemand(domain);
                        loadingEl.style.display = 'none';
                        
                        if (domainData) {
                            createChart(domain, domainData);
                        } else {
                            alert(`Could not load data for ${domain}`);
                        }
                    } else if (domains[domain]) {
                        createChart(domain, domains[domain]);
                    }
                }
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-dropdown')) {
                    dropdownList.classList.remove('open');
                }
            });
            
            // Keyboard navigation
            input.addEventListener('keydown', function(e) {
                const items = dropdownList.querySelectorAll('.dropdown-item');
                const currentIndex = Array.from(items).findIndex(item => item.classList.contains('highlighted'));
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    items.forEach(item => item.classList.remove('highlighted'));
                    const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                    items[nextIndex]?.classList.add('highlighted');
                    items[nextIndex]?.scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    items.forEach(item => item.classList.remove('highlighted'));
                    const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                    items[prevIndex]?.classList.add('highlighted');
                    items[prevIndex]?.scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const highlighted = dropdownList.querySelector('.dropdown-item.highlighted');
                    if (highlighted) {
                        highlighted.click();
                    } else if (items.length > 0) {
                        items[0].click();
                    }
                } else if (e.key === 'Escape') {
                    dropdownList.classList.remove('open');
                    input.blur();
                }
            });
        }

        // REVENUE LABEL CHANGE: Setup toggle event listener with dynamic update (no re-render)
        function setupRevenueToggle() {
            const toggle = document.getElementById('revenueLabelToggle');
            toggle.addEventListener('click', function() {
                showRevenueLabels = !showRevenueLabels;
                this.classList.toggle('active', showRevenueLabels);
                
                // Update chart annotations dynamically without full re-render
                if (currentChart) {
                    currentChart.updateOptions({
                        annotations: {
                            points: showRevenueLabels ? currentAnnotations : []
                        }
                    }, false, false); // redrawPaths=false, animate=false for instant toggle
                }
            });
        }
        
        // VIEW TOGGLE: Setup view toggle buttons (Monthly / Average / Both)
        function setupViewToggle() {
            const buttons = document.querySelectorAll('.view-btn');
            
            buttons.forEach(btn => {
                btn.addEventListener('click', function() {
                    const newView = this.dataset.view;
                    if (newView === currentView) return; // No change
                    
                    // Update active state
                    buttons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update current view
                    currentView = newView;
                    
                    // Re-render chart with new view
                    if (currentDomainData && currentDomainName) {
                        // Get current date range selection
                        const dateRangeSelect = document.getElementById('chartDateRange');
                        const currentDateRange = dateRangeSelect ? dateRangeSelect.value : 'dec2024';
                        createChart(currentDomainName, currentDomainData, currentDateRange);
                    }
                });
            });
        }

        // Calculate revenue rankings across all domains
        function calculateRevenueRankings(revenueByDomain) {
            const domainList = Object.keys(revenueByDomain);
            
            // Calculate totals for each ranking type
            const lifetimeRevenue = {};
            const last3MonthRevenue = {};
            const currentMonthRevenue = {};
            
            // Dynamically calculate months based on current date
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const now = new Date();
            const currentYear = now.getFullYear();
            const currentMonthIdx = now.getMonth(); // 0-indexed
            
            // Current month (incomplete - still in progress) - format: Jan2026 (no space)
            const currentMonth = `${monthNames[currentMonthIdx]}${currentYear}`;
            
            // Last 3 complete months (excluding current incomplete month) - format: Oct2025 (no space)
            const last3Months = [];
            for (let i = 3; i >= 1; i--) {
                const d = new Date(currentYear, currentMonthIdx - i, 1);
                last3Months.push(`${monthNames[d.getMonth()]}${d.getFullYear()}`);
            }
            
            domainList.forEach(domain => {
                const revenue = revenueByDomain[domain];
                lifetimeRevenue[domain] = Object.values(revenue).reduce((a, b) => a + b, 0);
                last3MonthRevenue[domain] = last3Months.reduce((sum, m) => sum + (revenue[m] || 0), 0);
                currentMonthRevenue[domain] = revenue[currentMonth] || 0;
            });
            
            // Calculate portfolio totals
            const portfolioTotals = {
                lifetime: Object.values(lifetimeRevenue).reduce((a, b) => a + b, 0),
                last3Month: Object.values(last3MonthRevenue).reduce((a, b) => a + b, 0),
                currentMonth: Object.values(currentMonthRevenue).reduce((a, b) => a + b, 0)
            };
            
            // Sort and assign ranks (1 = highest revenue)
            const sortAndRank = (obj) => {
                const sorted = Object.entries(obj).sort((a, b) => b[1] - a[1]);
                const ranks = {};
                sorted.forEach(([domain], idx) => ranks[domain] = idx + 1);
                return ranks;
            };
            
            return {
                lifetime: sortAndRank(lifetimeRevenue),
                last3Month: sortAndRank(last3MonthRevenue),
                currentMonth: sortAndRank(currentMonthRevenue),
                values: {
                    lifetime: lifetimeRevenue,
                    last3Month: last3MonthRevenue,
                    currentMonth: currentMonthRevenue
                },
                totals: portfolioTotals
            };
        }

        // Ahrefs URL Generator
        function getAhrefsUrl(domain) {
            return `https://app.ahrefs.com/v2-site-explorer/overview?backlinksChartMode=metrics&backlinksChartPerformanceSources=domainRating%7C%7CurlRating&backlinksCompetitorsSource=%22UrlRating%22&backlinksRefdomainsSource=%22RefDomainsNew%22&bestFilter=all&brandedTrafficSource=target-brand&chartGranularity=daily&chartInterval=all&competitors=&countries=&country=all&entitiesCategory=organisations&generalChartBrandedTraffic=other-brands&generalChartMode=metrics&generalChartPerformanceSources=organicTraffic&generalCompetitorsSource=%22OrganicTraffic%22&generalCountriesSource=organic-traffic&generalEntitiesChartMetric=Traffic&generalPagesByTrafficChartMode=Percentage&generalPagesByTrafficSource=Traffic&highlightChanges=7d&intentsMainSource=informational&keywordsSource=all&mode=subdomains&organicChartBrandedTraffic=non-branded%7C%7Cother-brands%7C%7Ctarget-brand&organicChartMode=metrics&organicChartPerformanceSources=organicTraffic&organicCompetitorsSource=%22OrganicTraffic%22&organicCountriesSource=organic-traffic&organicEntitiesChartMetric=Traffic&organicPagesByTrafficChartMode=Percentage&organicPagesByTrafficSource=Pages%7C%7CTraffic&overviewSerpChartMode=Own&overviewSerpChartSpec=AIOverview%7C%7CAdwordsBottom%7C%7CAdwordsTop%7C%7CDiscussions%7C%7CFeaturedSnippet%7C%7CImagePack%7C%7CKnowledgeCard%7C%7CKnowledgePanel%7C%7CLocalPack%7C%7CPaidSiteLinks%7C%7CPeopleAlsoAsk%7C%7CShoppingAds%7C%7CShoppingOrganic%7C%7CSitelinks%7C%7CThumbnail%7C%7CTopStories%7C%7CTweets%7C%7CVideoPreview%7C%7CVideos&overviewSerpManyChartSpec=Own%7C%7CTotal&overview_tab=general&paidSearchPaidKeywordsByTopPositionsChartMode=Percentage&paidTrafficSources=cost%7C%7Ctraffic&target=${encodeURIComponent(domain)}&topLevelDomainFilter=all&topOrganicKeywordsMode=normal&topOrganicPagesMode=normal&trafficType=Organic&volume_type=monthly`;
        }

        // Copy domain to clipboard
        function copyDomain(domain, event) {
            navigator.clipboard.writeText(domain).then(() => {
                const btn = event.target.closest('.copy-domain-btn');
                btn.classList.add('copied');
                setTimeout(() => btn.classList.remove('copied'), 1000);
            });
        }

        // CSV Loading Functions
        function parseCurrency(value) {
            if (!value || value === '' || value === '-') return 0;
            const cleaned = String(value).replace(/[$,]/g, '');
            return parseFloat(cleaned) || 0;
        }

        function parseNumber(value) {
            if (!value || value === '' || value === '-') return null;
            const cleaned = String(value).replace(/,/g, '');
            const num = parseInt(cleaned, 10);
            return isNaN(num) ? null : num;
        }

        function parseDate(dateStr) {
            // Convert "Jun 4 - 2025_1" to "Jun 4 2025" (remove dashes and _1/_2 suffixes)
            return dateStr.replace(/\s*-\s*/g, ' ').replace(/_\d+$/, '').trim();
        }

        function dateInRange(dateStr, startDate, endDate) {
            const date = parseDate(dateStr);
            const parts = date.split(' ');
            if (parts.length !== 3) return false;
            
            const [month, day, year] = parts;
            const dateObj = new Date(`${month} ${day}, ${year}`);
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            return dateObj >= start && dateObj <= end;
        }

        // Priority domains (computed dynamically from revenue rankings)
        let priorityDomains = [];
        // All domains available in traffic-data.csv (for search)
        let allAvailableDomains = new Set();
        // Cache for raw CSV data (for on-demand loading)
        let csvCache = {
            revenue: null,
            traffic: null,
            ahrefs: null,
            dr: null,
            internalAvg: null,
            ahrefsAvg: null
        };
        // Global revenue rankings for all domains
        let globalRevenueRankings = null;

        // Load ALL revenue data and compute priority domains
        async function loadRevenueCSVAndComputePriority() {
            try {
                const response = await fetch('revenue-history.csv');
                if (!response.ok) throw new Error('Failed to load revenue CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                // Cache the parsed data for on-demand loading
                csvCache.revenue = { parsed, headers: parsed.meta.fields || [] };
                
                const headers = parsed.meta.fields || [];
                const revenueByDomain = {};
                
                // Process ALL domains in the CSV
                parsed.data.forEach(row => {
                    const domain = row.Website;
                    if (!domain || domain === '-' || domain.trim() === '' || 
                        domain.toLowerCase() === 'unmatched payments') {
                        return;
                    }
                    
                    const monthlyRevenue = {};
                    headers.forEach(header => {
                        const monthMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/);
                        if (monthMatch) {
                            const [, month, year] = monthMatch;
                            const key = month + year;
                            const value = parseCurrency(row[header]);
                            if (value >= 0 && row[header] && row[header] !== '-') {
                                monthlyRevenue[key] = value;
                            }
                        }
                    });
                    revenueByDomain[domain] = monthlyRevenue;
                });
                
                // Calculate rankings for ALL domains
                globalRevenueRankings = calculateRevenueRankings(revenueByDomain);
                
                // Compute priority domains: top 100 from each period
                const top100Lifetime = Object.entries(globalRevenueRankings.values.lifetime)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 100)
                    .map(([domain]) => domain);
                    
                const top100Last3Month = Object.entries(globalRevenueRankings.values.last3Month)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 100)
                    .map(([domain]) => domain);
                    
                const top100CurrentMonth = Object.entries(globalRevenueRankings.values.currentMonth)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 100)
                    .map(([domain]) => domain);
                
                // Union all top domains
                const prioritySet = new Set([...top100Lifetime, ...top100Last3Month, ...top100CurrentMonth]);
                priorityDomains = Array.from(prioritySet);
                
                console.log(`âœ… Priority domains computed: ${priorityDomains.length} unique domains from top 100 of each period`);
                console.log('âœ… Revenue data loaded for ALL domains:', Object.keys(revenueByDomain).length);
                
                return revenueByDomain;
            } catch (error) {
                console.error('Error loading revenue CSV:', error);
                throw error;
            }
        }
        
        // Load revenue for specific domains (used for priority loading)
        async function loadRevenueForDomains(domainList, revenueByDomain) {
            const result = {};
            domainList.forEach(domain => {
                result[domain] = revenueByDomain[domain] || {};
            });
            return result;
        }

        async function loadDRHistoryCSV(domainList) {
            try {
                // Use cache if available
                if (!csvCache.dr) {
                    const response = await fetch('DR History.csv');
                    if (!response.ok) throw new Error('Failed to load DR History CSV');
                    
                    const text = await response.text();
                    const parsed = Papa.parse(text, { 
                        header: true,
                        skipEmptyLines: true
                    });
                    csvCache.dr = { parsed, headers: parsed.meta.fields || [] };
                }
                
                const { parsed, headers } = csvCache.dr;
                const drByDomain = {};
                
                // Process each domain in the list
                domainList.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const drDataMap = new Map();
                    
                    if (row) {
                        headers.forEach(header => {
                            const dateMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+)\s*-\s*(\d{4})$/);
                            if (dateMatch) {
                                const [, month, day, year] = dateMatch;
                                const dateStr = `${month} ${day} ${year}`;
                                const value = parseNumber(row[header]);
                                if (value !== null && value !== undefined) {
                                    if (!drDataMap.has(dateStr)) {
                                        drDataMap.set(dateStr, value);
                                    }
                                }
                            }
                        });
                    }
                    
                    drByDomain[domain] = drDataMap;
                });
                
                console.log('âœ… DR History data loaded for', domainList.length, 'domains');
                return drByDomain;
            } catch (error) {
                console.error('Error loading DR History CSV:', error);
                throw error;
            }
        }

        async function loadAhrefsCSV(domainList) {
            try {
                // Use cache if available
                if (!csvCache.ahrefs) {
                    const response = await fetch('ahrefs_organic_traffic_results.csv');
                    if (!response.ok) throw new Error('Failed to load Ahrefs CSV');
                    
                    const text = await response.text();
                    const parsed = Papa.parse(text, { 
                        header: true,
                        skipEmptyLines: true
                    });
                    csvCache.ahrefs = { parsed };
                }
                
                const { parsed } = csvCache.ahrefs;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const ahrefsByDomain = {};
                
                // Process each domain in the list
                domainList.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const ahrefsDataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.organic_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.organic_traffic);
                        if (value !== null && value !== undefined) {
                            ahrefsDataMap.set(dateStr, value);
                        }
                    });
                    
                    ahrefsByDomain[domain] = ahrefsDataMap;
                });
                
                console.log('âœ… Ahrefs data loaded for', domainList.length, 'domains');
                return ahrefsByDomain;
            } catch (error) {
                console.error('Error loading Ahrefs CSV:', error);
                throw error;
            }
        }

        async function loadInternalAverageCSV(domainList) {
            try {
                // Use cache if available
                if (!csvCache.internalAvg) {
                    const response = await fetch('internal-average-traffic.csv');
                    if (!response.ok) throw new Error('Failed to load Internal Average CSV');
                    
                    const text = await response.text();
                    const parsed = Papa.parse(text, { 
                        header: true,
                        skipEmptyLines: true
                    });
                    csvCache.internalAvg = { parsed };
                }
                
                const { parsed } = csvCache.internalAvg;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const internalAvgByDomain = {};
                
                // Process each domain in the list
                domainList.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const dataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.average_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.average_traffic);
                        if (value !== null && value !== undefined) {
                            dataMap.set(dateStr, value);
                        }
                    });
                    
                    internalAvgByDomain[domain] = dataMap;
                });
                
                console.log('âœ… Internal Average data loaded for', domainList.length, 'domains');
                return internalAvgByDomain;
            } catch (error) {
                console.warn('Warning loading Internal Average CSV:', error);
                const emptyResult = {};
                domainList.forEach(domain => emptyResult[domain] = new Map());
                return emptyResult;
            }
        }

        // Agent and Niche data lookup
        let agentNicheData = {};

        async function loadAgentNicheCSV() {
            try {
                const response = await fetch('Site Agent & Niche.csv');
                if (!response.ok) throw new Error('Failed to load Agent & Niche CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const dataByDomain = {};
                
                parsed.data.forEach(row => {
                    const domain = row.Website;
                    if (!domain || domain.trim() === '') return;
                    
                    dataByDomain[domain.toLowerCase()] = {
                        agent: row.Agent || '',
                        niche: row.Niche || ''
                    };
                });
                
                console.log('âœ… Agent & Niche data loaded:', Object.keys(dataByDomain).length, 'domains');
                return dataByDomain;
            } catch (error) {
                console.warn('Warning loading Agent & Niche CSV:', error);
                return {};
            }
        }

        async function loadAhrefsAverageCSV(domainList) {
            try {
                // Use cache if available
                if (!csvCache.ahrefsAvg) {
                    const response = await fetch('ahrefs-average-traffic.csv');
                    if (!response.ok) throw new Error('Failed to load Ahrefs Average CSV');
                    
                    const text = await response.text();
                    const parsed = Papa.parse(text, { 
                        header: true,
                        skipEmptyLines: true
                    });
                    csvCache.ahrefsAvg = { parsed };
                }
                
                const { parsed } = csvCache.ahrefsAvg;
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const ahrefsAvgByDomain = {};
                
                // Process each domain in the list
                domainList.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const dataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.average_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.average_traffic);
                        if (value !== null && value !== undefined) {
                            dataMap.set(dateStr, value);
                        }
                    });
                    
                    ahrefsAvgByDomain[domain] = dataMap;
                });
                
                console.log('âœ… Ahrefs Average data loaded for', domainList.length, 'domains');
                return ahrefsAvgByDomain;
            } catch (error) {
                console.warn('Warning loading Ahrefs Average CSV:', error);
                const emptyResult = {};
                domainList.forEach(domain => emptyResult[domain] = new Map());
                return emptyResult;
            }
        }

        async function loadTrafficCSV(domainList) {
            try {
                // Use cache if available, otherwise load and cache
                if (!csvCache.traffic) {
                    const response = await fetch('traffic-data.csv');
                    if (!response.ok) throw new Error('Failed to load traffic CSV');
                    
                    const text = await response.text();
                    const parsed = Papa.parse(text, { 
                        header: true,
                        skipEmptyLines: false,
                        transformHeader: (header) => header.trim()
                    });
                    
                    const headers = parsed.meta.fields || [];
                    const dateColumns = headers.slice(6);
                    
                    // Build date info once
                    const seenDates = new Map();
                    dateColumns.forEach((header, idx) => {
                        if (!header || header.trim() === '') return;
                        const dateStr = parseDate(header);
                        if (!dateStr || dateStr === '') return;
                        if (!seenDates.has(dateStr)) {
                            seenDates.set(dateStr, { firstIndex: idx, secondIndex: -1, headers: [header] });
                        } else {
                            const entry = seenDates.get(dateStr);
                            if (entry.secondIndex === -1) entry.secondIndex = idx;
                            entry.headers.push(header);
                        }
                    });
                    
                    let splitPoint = -1;
                    seenDates.forEach((entry) => {
                        if (entry.secondIndex !== -1 && (splitPoint === -1 || entry.secondIndex < splitPoint)) {
                            splitPoint = entry.secondIndex;
                        }
                    });
                    
                    // Populate allAvailableDomains from traffic data
                    parsed.data.forEach(row => {
                        if (row.Website && row.Website.trim() !== '') {
                            allAvailableDomains.add(row.Website.toLowerCase());
                        }
                    });
                    
                    csvCache.traffic = { parsed, headers, dateColumns, seenDates, splitPoint };
                    console.log('âœ… Traffic CSV cached, found', allAvailableDomains.size, 'total domains');
                }
                
                const { parsed, dateColumns, seenDates, splitPoint } = csvCache.traffic;
                const trafficByDomain = {};
                
                // Process each domain in the list
                domainList.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    if (!row) {
                        trafficByDomain[domain] = { dates: [], ourData: [] };
                        return;
                    }
                    
                    const ourDataMap = new Map();
                    
                    dateColumns.forEach((header, idx) => {
                        if (!header || header.trim() === '') return;
                        
                        const suffixMatch = header.match(/_(\d+)$/);
                        const hasSuffix = suffixMatch !== null;
                        const headerForDate = hasSuffix ? header.replace(/_(\d+)$/, '') : header;
                        const dateStr = parseDate(headerForDate);
                        if (!dateStr || dateStr === '') return;
                        
                        const parts = dateStr.split(' ');
                        if (parts.length !== 3) return;
                        
                        const [month, day, year] = parts;
                        const dateObj = new Date(`${month} ${day}, ${year}`);
                        if (isNaN(dateObj.getTime())) return;
                        
                        const value = parseNumber(row[header]);
                        
                        let isOurData = !hasSuffix;
                        if (!hasSuffix && splitPoint > 0 && idx >= splitPoint) {
                            const entry = seenDates.get(dateStr);
                            if (entry && entry.secondIndex !== -1 && idx >= entry.secondIndex) {
                                isOurData = false;
                            }
                        }
                        
                        if (isOurData && !ourDataMap.has(dateStr)) {
                            ourDataMap.set(dateStr, value);
                        }
                    });
                    
                    const sortedDates = Array.from(ourDataMap.keys()).sort((a, b) => {
                        const parseD = (s) => {
                            const p = s.split(' ');
                            return new Date(`${p[0]} ${p[1]}, ${p[2]}`);
                        };
                        return parseD(a) - parseD(b);
                    });
                    
                    const sortedOurData = sortedDates.map(d => ourDataMap.get(d));
                    
                    trafficByDomain[domain] = { dates: sortedDates, ourData: sortedOurData };
                });
                
                console.log('âœ… Traffic data loaded for', domainList.length, 'domains');
                return trafficByDomain;
            } catch (error) {
                console.error('Error loading traffic CSV:', error);
                throw error;
            }
        }

        async function initializeDashboard(data) {
            domains = data;
            
            // Setup event listeners
            setupDomainSelector();
            setupRevenueToggle(); // REVENUE LABEL CHANGE
            setupViewToggle(); // VIEW TOGGLE
            
            // Check for URL parameter to pre-select domain
            const urlParams = new URLSearchParams(window.location.search);
            const domainParam = urlParams.get('domain');
            
            // Determine which domain to show
            let targetDomain = null;
            let targetDomainData = null;
            
            if (domainParam) {
                // Check if domain is pre-loaded
                if (domains[domainParam]) {
                    targetDomain = domainParam;
                    targetDomainData = domains[domainParam];
                } 
                // Check if domain is available for on-demand loading
                else if (allAvailableDomains.has(domainParam.toLowerCase())) {
                    console.log(`Domain ${domainParam} requested via URL, loading on-demand...`);
                    const loadingEl = document.getElementById('loading');
                    loadingEl.style.display = 'block';
                    loadingEl.querySelector('div').textContent = `Loading ${domainParam}...`;
                    
                    targetDomainData = await loadDomainOnDemand(domainParam);
                    loadingEl.style.display = 'none';
                    
                    if (targetDomainData) {
                        targetDomain = domainParam;
                    }
                }
            }
            
            // Fallback to first pre-loaded domain
            if (!targetDomain && Object.keys(domains).length > 0) {
                targetDomain = Object.keys(domains)[0];
                targetDomainData = domains[targetDomain];
            }
            
            if (targetDomain && targetDomainData) {
                selectedDomain = targetDomain;
                document.getElementById('domainSearch').value = targetDomain;
                createChart(targetDomain, targetDomainData);
            }
        }

        // Helper to build a domain object from raw CSV data
        function buildDomainObject(domain, trafficData, ahrefsDataMap, revenueData, drDataMap, internalAvgMap, ahrefsAvgMap, revenueRankings) {
            const parseDateForSort = (dateStr) => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return new Date(0);
                const [month, day, year] = parts;
                return new Date(`${month} ${day}, ${year}`);
            };
            
            // Merge all dates
            const allDatesSet = new Set();
            trafficData.dates.forEach(d => allDatesSet.add(d));
            ahrefsDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
            drDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
            internalAvgMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
            ahrefsAvgMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
            
            // Add revenue dates
            Object.keys(revenueData).forEach(monthKey => {
                const noSpaceMatch = monthKey.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{4})$/);
                if (noSpaceMatch) {
                    const [, month, year] = noSpaceMatch;
                    allDatesSet.add(`${month} 1 ${year}`);
                }
            });
            
            const allDates = Array.from(allDatesSet).sort((a, b) => parseDateForSort(a) - parseDateForSort(b));
            
            // Build arrays
            const ourDataMap = new Map();
            trafficData.dates.forEach((date, i) => ourDataMap.set(date, trafficData.ourData[i]));
            
            const mergedDates = [];
            const mergedOurData = [];
            const mergedAhrefsData = [];
            const mergedDRData = [];
            const mergedInternalAvgData = [];
            const mergedAhrefsAvgData = [];
            
            allDates.forEach(dateStr => {
                mergedDates.push(dateStr);
                mergedOurData.push(ourDataMap.get(dateStr) || null);
                mergedAhrefsData.push(ahrefsDataMap.get(dateStr) || null);
                mergedDRData.push(drDataMap.get(dateStr) || null);
                mergedInternalAvgData.push(internalAvgMap.get(dateStr) || null);
                mergedAhrefsAvgData.push(ahrefsAvgMap.get(dateStr) || null);
            });
            
            // Get revenue values and calculate percentages
            const lifetimeVal = revenueRankings.values.lifetime[domain] || 0;
            const last3MonthVal = revenueRankings.values.last3Month[domain] || 0;
            const currentMonthVal = revenueRankings.values.currentMonth[domain] || 0;
            
            const lifetimePct = revenueRankings.totals.lifetime > 0 
                ? (lifetimeVal / revenueRankings.totals.lifetime * 100).toFixed(2) : 0;
            const last3MonthPct = revenueRankings.totals.last3Month > 0 
                ? (last3MonthVal / revenueRankings.totals.last3Month * 100).toFixed(2) : 0;
            const currentMonthPct = revenueRankings.totals.currentMonth > 0 
                ? (currentMonthVal / revenueRankings.totals.currentMonth * 100).toFixed(2) : 0;
            
            const totalDomains = Object.keys(revenueRankings.lifetime).length;
            
            return {
                rank: revenueRankings.lifetime[domain] || totalDomains,
                dates: mergedDates,
                ourData: mergedOurData,
                ahrefsData: mergedAhrefsData,
                drData: mergedDRData,
                internalAvgData: mergedInternalAvgData,
                ahrefsAvgData: mergedAhrefsAvgData,
                monthlyRevenue: revenueData,
                revenueRankings: {
                    lifetime: revenueRankings.lifetime[domain] || totalDomains,
                    last3Month: revenueRankings.last3Month[domain] || totalDomains,
                    currentMonth: revenueRankings.currentMonth[domain] || totalDomains,
                    lifetimeValue: lifetimeVal,
                    last3MonthValue: last3MonthVal,
                    currentMonthValue: currentMonthVal,
                    lifetimePct: lifetimePct,
                    last3MonthPct: last3MonthPct,
                    currentMonthPct: currentMonthPct
                }
            };
        }
        
        // On-demand loader for domains not in priority list
        async function loadDomainOnDemand(domain) {
            console.log(`ðŸ”„ Loading domain on-demand: ${domain}`);
            
            // Check if already loaded
            if (domains[domain]) {
                console.log(`âœ… Domain ${domain} already loaded`);
                return domains[domain];
            }
            
            // Check if domain exists in traffic data
            if (!allAvailableDomains.has(domain.toLowerCase())) {
                console.warn(`âš ï¸ Domain ${domain} not found in traffic data`);
                return null;
            }
            
            try {
                // Load data for just this domain from all cached CSVs
                const [trafficByDomain, ahrefsByDomain, drByDomain, internalAvgByDomain, ahrefsAvgByDomain] = await Promise.all([
                    loadTrafficCSV([domain]),
                    loadAhrefsCSV([domain]),
                    loadDRHistoryCSV([domain]),
                    loadInternalAverageCSV([domain]),
                    loadAhrefsAverageCSV([domain])
                ]);
                
                // Get revenue data from cache
                const revenueData = csvCache.revenue ? 
                    (() => {
                        const row = csvCache.revenue.parsed.data.find(r => 
                            r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                        );
                        if (!row) return {};
                        
                        const monthlyRevenue = {};
                        csvCache.revenue.headers.forEach(header => {
                            const monthMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/);
                            if (monthMatch) {
                                const [, month, year] = monthMatch;
                                const key = month + year;
                                const value = parseCurrency(row[header]);
                                if (value >= 0 && row[header] && row[header] !== '-') {
                                    monthlyRevenue[key] = value;
                                }
                            }
                        });
                        return monthlyRevenue;
                    })() : {};
                
                // Build domain object
                const trafficData = trafficByDomain[domain] || { dates: [], ourData: [] };
                const ahrefsDataMap = ahrefsByDomain[domain] || new Map();
                const drDataMap = drByDomain[domain] || new Map();
                const internalAvgMap = internalAvgByDomain[domain] || new Map();
                const ahrefsAvgMap = ahrefsAvgByDomain[domain] || new Map();
                
                const domainObj = buildDomainObject(
                    domain, trafficData, ahrefsDataMap, revenueData,
                    drDataMap, internalAvgMap, ahrefsAvgMap, globalRevenueRankings
                );
                
                // Cache it
                domains[domain] = domainObj;
                console.log(`âœ… Domain ${domain} loaded on-demand`);
                
                return domainObj;
            } catch (error) {
                console.error(`Error loading domain ${domain} on-demand:`, error);
                return null;
            }
        }

        async function loadDataFromCSV() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const errorMsg = document.getElementById('error-message');
            const chartsEl = document.getElementById('charts');
            
            const isFileProtocol = window.location.protocol === 'file:';
            
            if (isFileProtocol) {
                console.log('File protocol detected - using fallback data');
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
                return;
            }
            
            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                chartsEl.innerHTML = '';
                
                // Set timeout for CSV loading (10 seconds max for initial load)
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('CSV loading timeout')), 10000)
                );
                
                // STEP 1: Load revenue first and compute priority domains
                const revenueByDomain = await Promise.race([
                    loadRevenueCSVAndComputePriority(),
                    timeoutPromise
                ]);
                
                console.log('âœ… Priority domains:', priorityDomains.length);
                
                // STEP 2: Load other CSVs for priority domains only (parallel)
                const [trafficByDomain, ahrefsByDomain, drByDomain, internalAvgByDomain, ahrefsAvgByDomain, agentNicheByDomain] = await Promise.all([
                    loadTrafficCSV(priorityDomains),
                    loadAhrefsCSV(priorityDomains),
                    loadDRHistoryCSV(priorityDomains),
                    loadInternalAverageCSV(priorityDomains),
                    loadAhrefsAverageCSV(priorityDomains),
                    loadAgentNicheCSV()
                ]);
                
                // Store agent/niche data globally
                agentNicheData = agentNicheByDomain;
                
                // STEP 3: Build domains object for priority domains
                domains = {};
                
                priorityDomains.forEach(domain => {
                    const trafficData = trafficByDomain[domain] || { dates: [], ourData: [] };
                    const ahrefsDataMap = ahrefsByDomain[domain] || new Map();
                    const revenueData = revenueByDomain[domain] || {};
                    const drDataMap = drByDomain[domain] || new Map();
                    const internalAvgMap = internalAvgByDomain[domain] || new Map();
                    const ahrefsAvgMap = ahrefsAvgByDomain[domain] || new Map();
                    
                    domains[domain] = buildDomainObject(
                        domain, trafficData, ahrefsDataMap, revenueData, 
                        drDataMap, internalAvgMap, ahrefsAvgMap, globalRevenueRankings
                    );
                });
                
                console.log('âœ… Data merged for', Object.keys(domains).length, 'priority domains');
                
                loadingEl.style.display = 'none';
                initializeDashboard(domains);
            } catch (error) {
                console.warn('CSV loading failed, using fallback data:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
            }
        }

        // Initialize on page load - try CSV first, fallback to hardcoded
        loadDataFromCSV();

        // Check authentication and load user info
        async function checkAuthAndLoadUser() {
            try {
                const response = await fetch('/api/auth/check');
                const data = await response.json();
                
                if (!data.authenticated) {
                    // Not authenticated - redirect to login
                    window.location.href = '/api/auth/login?redirect=' + encodeURIComponent(window.location.pathname + window.location.search);
                    return;
                }
                
                // Authenticated - show the page and load user info
                document.body.style.visibility = 'visible';
                
                const meResponse = await fetch('/api/auth/me');
                const meData = await meResponse.json();
                if (meData.authenticated && meData.email) {
                    document.getElementById('userEmail').textContent = meData.email;
                    document.getElementById('userBar').style.display = 'flex';
                }
            } catch (error) {
                console.log('Auth check failed, showing page anyway');
                document.body.style.visibility = 'visible';
            }
        }
        checkAuthAndLoadUser();
    </script>
</body>
</html>
