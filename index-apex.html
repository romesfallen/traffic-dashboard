<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Dashboard - Premium</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #333333;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: #666666;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        select {
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 200px;
        }

        select:hover {
            border-color: #f97316;
            background: #ffffff;
        }

        select:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .stats-row {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #f5f5f5;
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666666;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        .stat-value.positive { color: #4ade80; }
        .stat-value.negative { color: #f87171; }
        .stat-value.neutral { color: #fbbf24; }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333333;
        }

        .chart-subtitle {
            font-size: 13px;
            color: #666666;
        }

        .chart-range-select {
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-range-select:hover {
            border-color: #f97316;
            background: #ffffff;
        }

        .chart-range-select:focus {
            outline: none;
            border-color: #f97316;
        }

        .legend {
            display: flex;
            gap: 24px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333333;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.our-data { background: linear-gradient(135deg, #f97316, #fb923c); }
        .legend-dot.ahrefs { background: linear-gradient(135deg, #3b82f6, #60a5fa); }
        .legend-dot.revenue { background: linear-gradient(135deg, #10b981, #34d399); }

        #chart-container {
            min-height: 400px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Traffic Comparison Dashboard</h1>
        <p>Our Data vs Ahrefs â€” All Available Data</p>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-dot our-data"></div>
            <span>Our Data</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot ahrefs"></div>
            <span>Ahrefs</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot revenue"></div>
            <span>Revenue</span>
        </div>
    </div>

    <div class="controls">
        <select id="domainSelect">
            <option value="">Select Domain</option>
        </select>
    </div>

    <div id="charts"></div>
    <div id="loading" style="display: none; text-align: center; padding: 40px; color: #666666;">
        <div style="font-size: 16px; margin-bottom: 12px;">Loading data...</div>
        <div style="font-size: 13px; color: #999999;">Parsing CSV files</div>
    </div>
    <div id="error" style="display: none; text-align: center; padding: 40px;">
        <div style="background: #fee; border: 1px solid #fcc; border-radius: 12px; padding: 24px; color: #c33;">
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Data</div>
            <div style="font-size: 13px;" id="error-message"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        let domains = {};
        
        // Fallback hardcoded data (used if CSV loading fails or for file:// protocol)
        const fallbackData = {
            "lyncconf.com": {
                "rank": 1,
                "dates": ["Jun 4 2025", "Jun 6 2025", "Jun 9 2025", "Jun 11 2025", "Jun 13 2025", "Jun 15 2025", "Jun 16 2025", "Jun 17 2025", "Jun 18 2025", "Jun 19 2025", "Jun 20 2025", "Jun 21 2025", "Jun 22 2025", "Jun 23 2025", "Jun 24 2025", "Jun 25 2025", "Jun 26 2025", "Jun 27 2025", "Jun 28 2025", "Jun 29 2025", "Jun 30 2025", "Jul 1 2025", "Jul 2 2025", "Jul 3 2025", "Jul 4 2025", "Jul 5 2025", "Jul 6 2025", "Jul 7 2025", "Jul 8 2025", "Jul 9 2025", "Jul 10 2025", "Jul 11 2025", "Jul 12 2025", "Jul 13 2025", "Jul 14 2025", "Jul 15 2025", "Jul 16 2025", "Jul 17 2025", "Jul 18 2025", "Jul 19 2025", "Jul 20 2025", "Jul 21 2025", "Jul 22 2025", "Jul 23 2025", "Jul 24 2025", "Jul 25 2025", "Jul 26 2025", "Jul 27 2025", "Jul 28 2025", "Jul 29 2025", "Jul 30 2025", "Jul 31 2025", "Aug 1 2025", "Aug 2 2025", "Aug 3 2025", "Aug 4 2025", "Aug 5 2025", "Aug 6 2025", "Aug 7 2025", "Aug 8 2025", "Aug 9 2025", "Aug 10 2025", "Aug 11 2025", "Aug 12 2025", "Aug 13 2025", "Aug 14 2025", "Aug 15 2025", "Aug 16 2025", "Aug 17 2025", "Aug 18 2025", "Aug 19 2025", "Aug 20 2025", "Aug 21 2025", "Aug 22 2025", "Aug 23 2025", "Aug 24 2025", "Aug 25 2025", "Aug 26 2025", "Aug 27 2025", "Aug 28 2025", "Aug 29 2025", "Aug 30 2025", "Aug 31 2025", "Sep 1 2025", "Sep 2 2025", "Sep 3 2025", "Sep 4 2025", "Sep 5 2025", "Sep 6 2025", "Sep 7 2025", "Sep 8 2025", "Sep 9 2025", "Sep 10 2025", "Sep 11 2025", "Sep 12 2025", "Sep 13 2025", "Sep 14 2025", "Sep 15 2025", "Sep 16 2025", "Sep 17 2025", "Sep 18 2025", "Sep 19 2025", "Sep 20 2025", "Sep 21 2025", "Sep 22 2025", "Sep 23 2025", "Sep 24 2025", "Sep 25 2025", "Sep 26 2025", "Sep 27 2025", "Sep 28 2025", "Sep 29 2025", "Sep 30 2025", "Oct 1 2025", "Oct 2 2025", "Oct 3 2025", "Oct 4 2025", "Oct 5 2025", "Oct 6 2025", "Oct 7 2025", "Oct 8 2025", "Oct 9 2025", "Oct 10 2025", "Oct 11 2025", "Oct 12 2025", "Oct 13 2025", "Oct 14 2025", "Oct 15 2025", "Oct 16 2025", "Oct 17 2025", "Oct 18 2025", "Oct 19 2025", "Oct 20 2025", "Oct 21 2025", "Oct 22 2025", "Oct 23 2025", "Oct 24 2025", "Oct 25 2025", "Oct 26 2025", "Oct 27 2025", "Oct 28 2025", "Oct 29 2025", "Oct 30 2025", "Oct 31 2025", "Nov 1 2025", "Nov 2 2025", "Nov 3 2025", "Nov 4 2025", "Nov 5 2025", "Nov 6 2025", "Nov 7 2025", "Nov 8 2025", "Nov 9 2025", "Nov 10 2025", "Nov 11 2025", "Nov 12 2025", "Nov 13 2025", "Nov 14 2025", "Nov 15 2025", "Nov 16 2025", "Nov 17 2025", "Nov 18 2025", "Nov 19 2025", "Nov 20 2025", "Nov 21 2025", "Nov 22 2025", "Nov 23 2025", "Nov 24 2025", "Nov 25 2025", "Nov 26 2025", "Nov 27 2025", "Nov 28 2025", "Nov 29 2025", "Nov 30 2025", "Dec 1 2025", "Dec 2 2025", "Dec 3 2025", "Dec 4 2025", "Dec 5 2025", "Dec 6 2025", "Dec 7 2025", "Dec 8 2025", "Dec 9 2025", "Dec 10 2025", "Dec 11 2025", "Dec 12 2025", "Dec 13 2025", "Dec 14 2025", "Dec 15 2025", "Dec 16 2025", "Dec 17 2025", "Dec 18 2025", "Dec 19 2025", "Dec 20 2025", "Dec 21 2025", "Dec 22 2025", "Dec 23 2025", "Dec 24 2025", "Dec 25 2025", "Dec 26 2025", "Dec 27 2025", "Dec 28 2025", "Dec 29 2025", "Dec 30 2025", "Dec 31 2025", "Jan 1 2026", "Jan 2 2026", "Jan 3 2026", "Jan 4 2026", "Jan 5 2026", "Jan 6 2026", "Jan 7 2026", "Jan 8 2026", "Jan 9 2026", "Jan 10 2026", "Jan 11 2026", "Jan 12 2026", "Jan 13 2026"],
                "ourData": [21181, 12214, 14683, 14853, 14853, 15828, 16243, 15436, 14741, 14591, 14727, 13648, 13652, 13630, 12950, 12785, 12250, 12168, 12758, 14113, 13908, 14377, 15564, 15544, 31400, 18697, 17470, 17697, 17702, 17436, 17045, null, null, null, 16256, 15751, 16753, 16786, 18064, 18444, 18560, 18826, 18574, 17890, null, 17453, 17140, 17515, 17472, 17966, 17692, 17796, 17788, 17691, 17966, 18013, 17807, 18917, 18062, 19593, 19893, 19857, 20241, 21025, 20957, 20979, 20757, 21519, 21324, 21689, 21238, 22351, 22236, 22078, 22354, 22372, 22572, 22134, 25845, 25669, 25275, 25641, 25896, 27240, 26132, 25311, 27678, 26710, 22632, 22060, 21772, 20044, 19439, 20014, 20337, 20468, 22754, 22839, 22863, 22027, 23249, 23045, 20593, 20627, 19835, 19944, 20549, 22075, 22146, 21869, 22935, 22359, 21876, 21857, 22162, 21277, 20967, 20787, 21752, 21080, 21134, 35709, 34312, 39097, 38726, 38991, 38769, 38588, 38377, 42276, 41954, 41584, 42779, 42335, 41994, 41333, 41222, 41196, 41253, 41331, 40501, 40914, 39037, 36227, 35709, 36243, 37719, 37708, 37206, 37153, 36398, 35574, 34636, 34273, 33938, 33092, 33291, 37877, 37846, 40497, 41423, 37901, 37756, 34484, 32813, 32759, 31730, 31411, 31133, 35860, 35727, 35466, 35534, 33597, 33725, 33969, 33876, 33239, 29435, 29435, 29435, 29499, 29318, 29332, 29060, 29056, 33879, 32360, 31831, 32154, 31830, 32360, 32273, 30332, 26822, 25631, 25645, 27155, 26979, 27054, 28928, 28757, 29755, 29266, 29757, 29253, 29255, 33132, 33346, 33206, 33196, 31908, 31758, 31450, 31720, 31528, 31688, 33221],
                "ahrefsData": [17528, 17527, 17186, 17523, 18024, 17792, 17977, 17593, 17404, 17257, 17189, 17204, 17218, 17231, 16822, 16528, 16154, 16641, 16946, 17137, 17012, 17271, 18026, 17927, 18299, 17851, 17701, 17802, 17731, 17337, 16765, 16442, 15874, 15386, 15074, 14772, 14817, 14566, 14575, 14401, 14444, 14705, 14532, 14530, 14220, 14379, 14276, 14016, 13828, 14019, 14058, 14039, 14200, 14291, 14674, 15683, 16767, 16973, 16861, 16951, 17571, 17970, 17935, 18359, 18498, 17629, 18192, 18461, 18206, 18342, 18807, 18556, 18453, 18828, 18855, 18331, 18499, 18902, 19215, 19260, 18655, 18479, 19183, 26261, 27209, 31515, 32057, 37858, 39789, 41136, 43910, 43490, 44102, 44949, 49039, 53254, 54810, 55483, 55860, 59064, 59505, 60087, 59502, 59714, 61523, 62437, 66084, 66295, 65929, 66803, 67012, 66667, 65457, 65294, 77416, 78362, 80187, 82054, 82102, 83507, 85663, 85012, 84857, 87302, 86783, 90198, 89738, 89679, 89303, 89287, 88653, 89210, 89792, 89049, 89206, 89521, 89308, 89491, 89589, 89437, 90023, 87930, 87415, 87761, 87824, 83780, 80815, 81108, 81137, 80606, 78352, 76677, 75936, 74946, 75697, 75902, 72775, 72194, 71603, 72297, 63810, 64307, 62909, 61219, 59119, 59079, 59178, 58832, 58824, 58272, 58092, 57793, 56335, 55104, 54808, 54797, 52267, 49815, 49815, 49815, 49804, 49030, 47758, 47372, 47377, 47392, 44775, 43091, 44252, 43685, 44094, 44010, 41503, 39458, 37858, 37163, 37451, 37281, 37832, 37197, 37162, 36846, 35246, 34897, 34439, 34555, 34444, 34729, 34686, 34582, 33974, 33946, 33551, 33270, 33193, 33178, 33322, 33180],
                "ourChange": "+56.8%",
                "ahrefsChange": "+89.3%"
            }
        };

        function getStatClass(value) {
            const num = parseFloat(value);
            if (num > 5) return 'positive';
            if (num < -5) return 'negative';
            return 'neutral';
        }

        // Linear interpolation for missing data
        function interpolateData(arr) {
            const real = [...arr];
            const estimated = new Array(arr.length).fill(null);
            const isEstimated = new Array(arr.length).fill(false);
            
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === null) {
                    let prevIdx = i - 1;
                    while (prevIdx >= 0 && arr[prevIdx] === null) prevIdx--;
                    
                    let nextIdx = i + 1;
                    while (nextIdx < arr.length && arr[nextIdx] === null) nextIdx++;
                    
                    if (prevIdx >= 0 && nextIdx < arr.length) {
                        const prevVal = arr[prevIdx];
                        const nextVal = arr[nextIdx];
                        const steps = nextIdx - prevIdx;
                        const step = (nextVal - prevVal) / steps;
                        const interpolated = Math.round(prevVal + step * (i - prevIdx));
                        
                        real[i] = interpolated;
                        estimated[i] = interpolated;
                        isEstimated[i] = true;
                    }
                }
            }
            
            return { real, estimated, isEstimated };
        }

        // Filter data by date range
        function filterByDateRange(data, days) {
            if (days === 'all') {
                return {
                    dates: data.dates,
                    ourData: data.ourData,
                    ahrefsData: data.ahrefsData
                };
            }
            
            const numDays = parseInt(days);
            const totalPoints = data.dates.length;
            const startIdx = Math.max(0, totalPoints - numDays);
            
            return {
                dates: data.dates.slice(startIdx),
                ourData: data.ourData.slice(startIdx),
                ahrefsData: data.ahrefsData.slice(startIdx)
            };
        }

        // Generate monthly revenue with dynamic 80% width blocks
        // Uses actual calendar days, not data point count
        function generateMonthlyRevenue(dates, monthlyRevenueData = null) {
            // Use CSV data if provided, otherwise use default
            const monthRevenue = monthlyRevenueData || {
                'Jun2025': 100, 'Jul2025': 200, 'Aug2025': 300, 'Sep2025': 400,
                'Oct2025': 500, 'Nov2025': 600, 'Dec2025': 700, 'Jan2026': 800
            };
            
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Helper: Get days in a specific month
            function getDaysInMonth(year, monthIndex) {
                return new Date(year, monthIndex + 1, 0).getDate();
            }
            
            // Helper: Parse "Jan 1 2024" to Date object
            function parseDate(dateStr) {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return null;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return null;
                return new Date(parseInt(year), monthIndex, parseInt(day));
            }
            
            // Helper: Get the 80% cutoff day for a month
            function get80PercentDay(year, monthIndex) {
                const daysInMonth = getDaysInMonth(year, monthIndex);
                return Math.floor(daysInMonth * 0.8);
            }
            
            // Step A: Build month info map with calendar-based calculations
            const monthInfo = {};
            dates.forEach((dateStr, idx) => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                
                const [month, day, year] = parts;
                const key = month + year; // e.g., "Jun2025"
                const dayNum = parseInt(day);
                const monthIndex = monthNames.indexOf(month);
                const yearNum = parseInt(year);
                
                if (!monthInfo[key]) {
                    const cutoffDay = get80PercentDay(yearNum, monthIndex);
                    const daysInMonth = getDaysInMonth(yearNum, monthIndex);
                    monthInfo[key] = {
                        month: month,
                        year: year,
                        monthIndex: monthIndex,
                        yearNum: yearNum,
                        cutoffDay: cutoffDay, // Day number where 80% ends
                        daysInMonth: daysInMonth,
                        firstDataIdx: idx,
                        lastDataIdx: idx,
                        midLabelIdx: null // Will calculate after we know all indices
                    };
                } else {
                    monthInfo[key].lastDataIdx = idx;
                }
            });
            
            // Step B: Generate revenue array and categories
            const revenue = new Array(dates.length).fill(0);
            const categories = new Array(dates.length).fill(' ');
            
            // Process each date point
            dates.forEach((dateStr, idx) => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                
                const [month, day, year] = parts;
                const key = month + year;
                const dayNum = parseInt(day);
                const info = monthInfo[key];
                
                if (!info) return;
                
                const revenueValue = monthRevenue[key] || 0;
                
                // Dynamic 80% width: Show revenue if day <= 80% cutoff day
                // This is based on actual calendar days, not data point count
                if (dayNum <= info.cutoffDay) {
                    revenue[idx] = revenueValue;
                }
                // Days after cutoffDay stay at 0 (creates the gap)
            });
            
            // Calculate mid-point for labels (center of the 80% block visually)
            Object.entries(monthInfo).forEach(([key, info]) => {
                // Find the index closest to mid-month (around day 12-15)
                const targetDay = Math.floor(info.cutoffDay / 2); // Middle of the 80% block
                let bestIdx = info.firstDataIdx;
                let bestDiff = Infinity;
                
                for (let i = info.firstDataIdx; i <= info.lastDataIdx; i++) {
                    const parts = dates[i].split(' ');
                    if (parts.length !== 3) continue;
                    const dayNum = parseInt(parts[1]);
                    const diff = Math.abs(dayNum - targetDay);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        bestIdx = i;
                    }
                }
                
                // Set label at mid-point of the 80% block
                categories[bestIdx] = info.month + ' ' + info.year;
            });
            
            return { revenue, categories };
        }

        // Calculate change percentage for filtered data
        function calcChange(arr) {
            const validData = arr.filter(v => v !== null && v !== undefined);
            if (validData.length < 2) return 'N/A';
            const first = validData[0];
            const last = validData[validData.length - 1];
            const change = ((last - first) / first * 100).toFixed(1);
            return (change >= 0 ? '+' : '') + change + '%';
        }

        function createChart(domain, data, dateRange = 'all') {
            const chartsDiv = document.getElementById('charts');
            chartsDiv.innerHTML = '';

            const filtered = filterByDateRange(data, dateRange);
            const ourChange = calcChange(filtered.ourData);
            const ahrefsChange = calcChange(filtered.ahrefsData);

            const card = document.createElement('div');
            card.className = 'card';

            card.innerHTML = `
                <div class="chart-header">
                    <div>
                        <div class="chart-title">${domain}</div>
                        <div class="chart-subtitle">Rank #${data.rank}</div>
                    </div>
                    <select class="chart-range-select" id="chartDateRange">
                        <option value="7" ${dateRange === '7' ? 'selected' : ''}>Last 7 days</option>
                        <option value="30" ${dateRange === '30' ? 'selected' : ''}>Last month</option>
                        <option value="90" ${dateRange === '90' ? 'selected' : ''}>Last 3 months</option>
                        <option value="180" ${dateRange === '180' ? 'selected' : ''}>Last 6 months</option>
                        <option value="365" ${dateRange === '365' ? 'selected' : ''}>Last year</option>
                        <option value="all" ${dateRange === 'all' ? 'selected' : ''}>All time</option>
                    </select>
                </div>
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">Our Data Change</div>
                        <div class="stat-value ${getStatClass(ourChange)}">${ourChange}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Ahrefs Change</div>
                        <div class="stat-value ${getStatClass(ahrefsChange)}">${ahrefsChange}</div>
                    </div>
                </div>
                <div id="apex-chart"></div>
            `;
            chartsDiv.appendChild(card);

            document.getElementById('chartDateRange').addEventListener('change', function() {
                createChart(domain, data, this.value);
            });

            const ourProcessed = interpolateData(filtered.ourData);
            const ahrefsProcessed = interpolateData(filtered.ahrefsData);
            const revenueResult = generateMonthlyRevenue(filtered.dates, data.monthlyRevenue);
            const revenueData = revenueResult.revenue;
            // Use revenue-generated categories (mid-month positioned labels)
            const xCategories = revenueResult.categories;
            
            // Debug logging
            console.log('Chart data:', {
                ourDataLength: ourProcessed.real.length,
                ahrefsDataLength: ahrefsProcessed.real.length,
                revenueDataLength: revenueData.length,
                ourDataSample: ourProcessed.real.slice(0, 5),
                ahrefsDataSample: ahrefsProcessed.real.slice(0, 5),
                revenueSample: revenueData.slice(0, 5)
            });

            const options = {
                series: [{
                    name: 'Our Data',
                    type: 'area',
                    data: ourProcessed.real
                }, {
                    name: 'Ahrefs',
                    type: 'area',
                    data: ahrefsProcessed.real
                }, {
                    name: 'Revenue',
                    type: 'column',
                    data: revenueData
                }],
                chart: {
                    type: 'line',
                    height: 480,
                    background: 'transparent',
                    toolbar: { show: true, tools: { download: true, zoom: true, pan: true } },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    },
                    stacked: false
                },
                plotOptions: {
                    bar: {
                        columnWidth: xCategories.length > 365 ? '95%' : xCategories.length > 180 ? '90%' : '80%',
                        distributed: false
                    }
                },
                colors: ['#f97316', '#3b82f6', '#10b981'],
                fill: {
                    type: ['gradient', 'gradient', 'solid'],
                    gradient: {
                        shadeIntensity: 1,
                        opacityFrom: [0.5, 0.5, 1],
                        opacityTo: [0.1, 0.1, 1],
                        stops: [0, 90, 100]
                    },
                    opacity: [1, 1, 0.5]
                },
                stroke: {
                    curve: ['smooth', 'smooth', 'stepline'],
                    width: [2, 2, 0]
                },
                markers: {
                    size: 0,
                    hover: { size: 4 }
                },
                xaxis: {
                    type: 'category',
                    categories: xCategories,
                    labels: {
                        style: { colors: '#333333', fontSize: '11px', fontWeight: 500 },
                        rotate: 0,
                        rotateAlways: false,
                        hideOverlappingLabels: true,
                        minHeight: 40,
                        formatter: function(value, timestamp, opts) {
                            // Categories are mostly ' ' (space) with "Jun 2025" at mid-month
                            const trimmed = String(value).trim();
                            if (!trimmed) return '';
                            
                            // Parse "Jun 2025" format
                            const parts = trimmed.split(' ');
                            if (parts.length !== 2) return '';
                            
                            const [month, year] = parts;
                            const monthIndex = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'].indexOf(month);
                            if (monthIndex === -1) return '';
                            
                            // Calculate total months to determine label frequency
                            const totalMonths = Math.ceil(xCategories.length / 30);
                            
                            // Filter labels based on data range to prevent overcrowding
                            if (totalMonths <= 12) {
                                // Up to 1 year: show every month
                                return month + ' ' + year;
                            } else if (totalMonths <= 24) {
                                // 1-2 years: show every other month
                                if (monthIndex % 2 === 0) return month + ' ' + year;
                            } else if (totalMonths <= 36) {
                                // 2-3 years: show quarterly
                                if (monthIndex % 3 === 0) return month + ' ' + year;
                            } else {
                                // 3+ years: show every 4 months
                                if (monthIndex % 4 === 0) return month + ' ' + year;
                            }
                            return '';
                        }
                    },
                    axisBorder: { color: '#cccccc' },
                    axisTicks: { show: false },
                    crosshairs: {
                        show: true,
                        stroke: { color: '#999999', width: 1, dashArray: 3 }
                    },
                    tooltip: { enabled: false }
                },
                yaxis: [{
                    seriesName: ['Our Data', 'Ahrefs'],
                    title: {
                        text: 'Traffic',
                        style: { color: '#333333', fontSize: '12px' }
                    },
                    labels: {
                        style: { colors: '#333333' },
                        formatter: val => val ? val.toLocaleString() : ''
                    },
                    min: 0
                }, {
                    seriesName: 'Revenue',
                    opposite: true,
                    title: {
                        text: 'Revenue ($)',
                        style: { color: '#10b981', fontSize: '12px' }
                    },
                    labels: {
                        style: { colors: '#10b981' },
                        formatter: val => val ? '$' + val.toLocaleString() : ''
                    },
                    min: 0
                    // Removed max: 1000 to allow auto-scaling
                }],
                grid: {
                    borderColor: '#e8e8e8',
                    strokeDashArray: 0,
                    padding: {
                        left: 10,
                        right: 30,
                        bottom: 15
                    }
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'left',
                    offsetY: 0,
                    labels: { colors: '#333333' },
                    markers: { width: 10, height: 10, radius: 10 }
                },
                tooltip: {
                    enabled: true,
                    shared: true,
                    intersect: false,
                    followCursor: true,
                    custom: function({ series, seriesIndex, dataPointIndex, w }) {
                        // Get the date for the header
                        const date = filtered.dates[dataPointIndex];
                        let dateStr = '';
                        if (date) {
                            const parts = date.split(' ');
                            dateStr = parts[1] + ' ' + parts[0] + ' ' + parts[2];
                        }
                        
                        // Get collapsed (hidden) series indices
                        const collapsed = w.globals.collapsedSeriesIndices || [];
                        
                        // Series config
                        const seriesConfig = [
                            { name: 'Our Data', color: '#f97316', suffix: ' visits' },
                            { name: 'Ahrefs', color: '#3b82f6', suffix: ' visits' },
                            { name: 'Revenue', color: '#10b981', prefix: '$', suffix: '' }
                        ];
                        
                        // Build tooltip HTML with consistent padding
                        let html = '<div style="background: #fff; border: 1px solid #e5e5e5; border-radius: 6px; padding: 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); font-family: Inter, sans-serif; min-width: 140px;">';
                        html += '<div style="font-weight: 600; color: #333; margin-bottom: 6px; font-size: 12px;">' + dateStr + '</div>';
                        
                        // Add each visible series
                        let hasContent = false;
                        for (let i = 0; i < series.length; i++) {
                            // Skip if series is collapsed/hidden
                            if (collapsed.includes(i)) continue;
                            
                            const val = series[i][dataPointIndex];
                            // Skip if value is null/undefined or 0 for revenue gaps
                            if (val === null || val === undefined) continue;
                            if (i === 2 && val === 0) continue; // Skip revenue gaps
                            
                            const config = seriesConfig[i];
                            const formattedVal = (config.prefix || '') + val.toLocaleString() + (config.suffix || '');
                            
                            html += '<div style="display: flex; align-items: center; gap: 6px; margin-top: 4px;">';
                            html += '<span style="width: 8px; height: 8px; border-radius: 50%; background: ' + config.color + '; flex-shrink: 0;"></span>';
                            html += '<span style="color: #666; font-size: 11px;">' + config.name + ':</span>';
                            html += '<span style="font-weight: 600; color: #333; font-size: 11px;">' + formattedVal + '</span>';
                            html += '</div>';
                            hasContent = true;
                        }
                        
                        html += '</div>';
                        
                        return hasContent ? html : '';
                    }
                },
                dataLabels: { enabled: false }
            };

            const chart = new ApexCharts(document.querySelector('#apex-chart'), options);
            chart.render();
        }

        // Event listener for domain selector (will be set up after data loads)
        function setupDomainSelector() {
            const select = document.getElementById('domainSelect');
            select.addEventListener('change', function() {
                if (this.value && domains[this.value]) {
                    createChart(this.value, domains[this.value]);
                }
            });
        }

        // CSV Loading Functions
        function parseCurrency(value) {
            if (!value || value === '' || value === '-') return 0;
            const cleaned = String(value).replace(/[$,]/g, '');
            return parseFloat(cleaned) || 0;
        }

        function parseNumber(value) {
            if (!value || value === '' || value === '-') return null;
            const cleaned = String(value).replace(/,/g, '');
            const num = parseInt(cleaned, 10);
            return isNaN(num) ? null : num;
        }

        function parseDate(dateStr) {
            // Convert "Jun 4 - 2025_1" to "Jun 4 2025" (remove dashes and _1/_2 suffixes)
            return dateStr.replace(/\s*-\s*/g, ' ').replace(/_\d+$/, '').trim();
        }

        function dateInRange(dateStr, startDate, endDate) {
            const date = parseDate(dateStr);
            const parts = date.split(' ');
            if (parts.length !== 3) return false;
            
            const [month, day, year] = parts;
            const dateObj = new Date(`${month} ${day}, ${year}`);
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            return dateObj >= start && dateObj <= end;
        }

        async function loadRevenueCSV() {
            try {
                const response = await fetch('revenue-history.csv');
                if (!response.ok) throw new Error('Failed to load revenue CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                // Find lyncconf.com row
                const lyncconfRow = parsed.data.find(row => 
                    row.Website && row.Website.toLowerCase() === 'lyncconf.com'
                );
                
                if (!lyncconfRow) {
                    throw new Error('lyncconf.com not found in revenue CSV');
                }
                
                // Extract monthly revenue values
                const monthlyRevenue = {};
                const headers = parsed.meta.fields || [];
                
                // Month names mapping
                const monthMap = {
                    'Jan': 'Jan', 'Feb': 'Feb', 'Mar': 'Mar', 'Apr': 'Apr',
                    'May': 'May', 'Jun': 'Jun', 'Jul': 'Jul', 'Aug': 'Aug',
                    'Sep': 'Sep', 'Oct': 'Oct', 'Nov': 'Nov', 'Dec': 'Dec'
                };
                
                headers.forEach(header => {
                    // Check if header is a month (e.g., "Jan 2022", "Jun 2025")
                    const monthMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/);
                    if (monthMatch) {
                        const [, month, year] = monthMatch;
                        const key = month + year; // e.g., "Jun2025"
                        const value = parseCurrency(lyncconfRow[header]);
                        if (value > 0) {
                            monthlyRevenue[key] = value;
                        }
                    }
                });
                
                return monthlyRevenue;
            } catch (error) {
                console.error('Error loading revenue CSV:', error);
                throw error;
            }
        }

        async function loadAhrefsCSV() {
            try {
                const response = await fetch('ahrefs-data.csv');
                if (!response.ok) throw new Error('Failed to load Ahrefs CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                // Filter for lyncconf.com
                const lyncconfRows = parsed.data.filter(row => 
                    row.domain && row.domain.toLowerCase() === 'lyncconf.com'
                );
                
                if (lyncconfRows.length === 0) {
                    throw new Error('lyncconf.com not found in Ahrefs CSV');
                }
                
                // Convert to map: date string -> traffic value
                const ahrefsDataMap = new Map();
                
                lyncconfRows.forEach(row => {
                    if (!row.date || !row.organic_traffic) return;
                    
                    // Parse ISO date: "2024-01-01T00:00:00Z" -> "Jan 1 2024"
                    const isoDate = new Date(row.date);
                    if (isNaN(isoDate.getTime())) return;
                    
                    // Format to match traffic CSV format: "Jan 1 2024"
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const month = monthNames[isoDate.getMonth()];
                    const day = isoDate.getDate();
                    const year = isoDate.getFullYear();
                    const dateStr = `${month} ${day} ${year}`;
                    
                    const value = parseNumber(row.organic_traffic);
                    if (value !== null && value !== undefined) {
                        ahrefsDataMap.set(dateStr, value);
                    }
                });
                
                console.log('âœ… Ahrefs data loaded:', {
                    totalRows: lyncconfRows.length,
                    dataPoints: ahrefsDataMap.size,
                    firstDate: Array.from(ahrefsDataMap.keys()).sort()[0],
                    lastDate: Array.from(ahrefsDataMap.keys()).sort().slice(-1)[0],
                    sampleValues: Array.from(ahrefsDataMap.entries()).slice(0, 5)
                });
                
                return ahrefsDataMap;
            } catch (error) {
                console.error('Error loading Ahrefs CSV:', error);
                throw error;
            }
        }

        async function loadTrafficCSV() {
            try {
                const response = await fetch('traffic-data.csv');
                if (!response.ok) throw new Error('Failed to load traffic CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: false,
                    transformHeader: (header) => header.trim() // Clean headers
                });
                
                // Find lyncconf.com row
                const lyncconfRow = parsed.data.find(row => 
                    row.Website && row.Website.toLowerCase() === 'lyncconf.com'
                );
                
                if (!lyncconfRow) {
                    throw new Error('lyncconf.com not found in traffic CSV');
                }
                
                const headers = parsed.meta.fields || [];
                // Skip first 6 columns: empty, Website, Ahrefs Links, Link Working, Type, "Original \nType"
                const dateColumns = headers.slice(6);
                
                // No date filtering - show all available data from CSV
                // (Previously filtered to June 4 2025 - Jan 13 2026, now showing all)
                
                const dates = [];
                const ourData = [];
                // Note: ahrefsData will come from separate CSV file, not from this one
                const ahrefsData = []; // This will be empty - we'll fill it from Ahrefs CSV
                
                // Track which dates we've seen to detect duplicates
                const seenDates = new Map(); // dateStr -> { firstIndex, secondIndex }
                
                // First pass: identify duplicate dates and their positions
                dateColumns.forEach((header, idx) => {
                    if (!header || header.trim() === '') return;
                    
                    const dateStr = parseDate(header);
                    if (!dateStr || dateStr === '') return;
                    
                    if (!seenDates.has(dateStr)) {
                        seenDates.set(dateStr, { firstIndex: idx, secondIndex: -1, headers: [header] });
                    } else {
                        const entry = seenDates.get(dateStr);
                        if (entry.secondIndex === -1) {
                            entry.secondIndex = idx;
                        }
                        entry.headers.push(header);
                    }
                });
                
                // Find the split point (where duplicates start appearing)
                let splitPoint = -1;
                seenDates.forEach((entry, dateStr) => {
                    if (entry.secondIndex !== -1 && (splitPoint === -1 || entry.secondIndex < splitPoint)) {
                        splitPoint = entry.secondIndex;
                    }
                });
                
                console.log('ðŸ” DEBUG: Duplicate detection', {
                    totalDateColumns: dateColumns.length,
                    uniqueDates: seenDates.size,
                    datesWithDuplicates: Array.from(seenDates.entries()).filter(([_, entry]) => entry.secondIndex !== -1).length,
                    splitPoint: splitPoint,
                    sampleDuplicates: Array.from(seenDates.entries())
                        .filter(([_, entry]) => entry.secondIndex !== -1)
                        .slice(0, 5)
                        .map(([dateStr, entry]) => ({
                            date: dateStr,
                            firstIdx: entry.firstIndex,
                            secondIdx: entry.secondIndex,
                            headers: entry.headers
                        }))
                });
                
                // Build date-to-index maps for both sections
                const ourDataMap = new Map(); // date -> {index, value}
                const ahrefsDataMap = new Map(); // date -> value
                const assignmentLog = []; // For debugging
                
                dateColumns.forEach((header, idx) => {
                    if (!header || header.trim() === '') return;
                    
                    // Check for PapaParse suffix (_1, _2, etc.)
                    const suffixMatch = header.match(/_(\d+)$/);
                    const hasSuffix = suffixMatch !== null;
                    const suffixNum = hasSuffix ? parseInt(suffixMatch[1]) : 0;
                    
                    // Remove suffix for date parsing
                    const headerForDate = hasSuffix ? header.replace(/_(\d+)$/, '') : header;
                    const dateStr = parseDate(headerForDate);
                    if (!dateStr || dateStr === '') return;
                    
                    const parts = dateStr.split(' ');
                    if (parts.length !== 3) return;
                    
                    const [month, day, year] = parts;
                    const dateObj = new Date(`${month} ${day}, ${year}`);
                    
                    if (isNaN(dateObj.getTime())) {
                        // Skip invalid dates (but don't log _1/_2 suffixes as they're expected)
                        if (!hasSuffix) {
                            console.warn('Invalid date format:', header, '->', dateStr);
                        }
                        return;
                    }
                    
                    // Include all dates (no filtering) - even if value is null/empty
                    const value = parseNumber(lyncconfRow[header]);
                    
                    // Determine which dataset:
                    // PapaParse adds _1 to the SECOND occurrence of duplicate column names
                    // So: no suffix = first occurrence (ourData), _1 suffix = second occurrence (ahrefsData)
                    // 1. If header has ANY suffix (_1, _2, etc.), it's ahrefsData (second+ occurrence)
                    // 2. If header has no suffix AND we're before split point, it's ourData
                    // 3. If header has no suffix AND we're at/after split point, check if this date was seen before
                    let isAhrefsData = false;
                    let assignmentReason = '';
                    
                    if (hasSuffix) {
                        // ANY suffix (_1, _2, etc.) means this is a duplicate column = ahrefsData
                        isAhrefsData = true;
                        assignmentReason = `suffix_${suffixNum}_duplicate`;
                    } else if (splitPoint > 0 && idx >= splitPoint) {
                        // We're in the second section (after split point) but no suffix
                        // Check if this date was already seen (duplicate)
                        const entry = seenDates.get(dateStr);
                        if (entry && entry.secondIndex !== -1 && idx >= entry.secondIndex) {
                            isAhrefsData = true;
                            assignmentReason = `split_point_duplicate_no_suffix`;
                        } else {
                            assignmentReason = `split_point_new_date_no_suffix`;
                        }
                    } else {
                        // No suffix and before split point = first occurrence = ourData
                        assignmentReason = `first_section_no_suffix`;
                    }
                    
                    if (isAhrefsData) {
                        // This is ahrefsData
                        if (!ahrefsDataMap.has(dateStr)) {
                            ahrefsDataMap.set(dateStr, value);
                            assignmentLog.push({
                                date: dateStr,
                                header: header,
                                idx: idx,
                                value: value,
                                dataset: 'ahrefs',
                                reason: assignmentReason
                            });
                        } else {
                            assignmentLog.push({
                                date: dateStr,
                                header: header,
                                idx: idx,
                                value: value,
                                dataset: 'ahrefs',
                                reason: `${assignmentReason}_skipped_already_exists`,
                                existingValue: ahrefsDataMap.get(dateStr)
                            });
                        }
                    } else {
                        // This is ourData
                        if (!ourDataMap.has(dateStr)) {
                            ourDataMap.set(dateStr, { index: ourDataMap.size, value: value });
                            assignmentLog.push({
                                date: dateStr,
                                header: header,
                                idx: idx,
                                value: value,
                                dataset: 'our',
                                reason: assignmentReason
                            });
                        } else {
                            assignmentLog.push({
                                date: dateStr,
                                header: header,
                                idx: idx,
                                value: value,
                                dataset: 'our',
                                reason: `${assignmentReason}_skipped_already_exists`,
                                existingValue: ourDataMap.get(dateStr).value
                            });
                        }
                    }
                });
                
                // Debug: Check for dates that appear in both datasets with same values
                const sameValueDates = [];
                ourDataMap.forEach((ourEntry, dateStr) => {
                    if (ahrefsDataMap.has(dateStr)) {
                        const ourValue = ourEntry.value;
                        const ahrefsValue = ahrefsDataMap.get(dateStr);
                        if (ourValue === ahrefsValue && ourValue !== null && ourValue !== undefined) {
                            sameValueDates.push({ date: dateStr, value: ourValue });
                        }
                    }
                });
                
                console.log('ðŸ” DEBUG: Data assignment', {
                    totalColumnsProcessed: assignmentLog.length,
                    ourDataMapSize: ourDataMap.size,
                    ahrefsDataMapSize: ahrefsDataMap.size,
                    datesInBoth: Array.from(ourDataMap.keys()).filter(d => ahrefsDataMap.has(d)).length,
                    sameValueDates: sameValueDates.length,
                    sampleSameValues: sameValueDates.slice(0, 10),
                    sampleAssignments: assignmentLog.filter(a => a.date.includes('Jul 17 2025') || a.date.includes('Dec 24 2025')).slice(0, 10)
                });
                
                // Build arrays from maps, matching dates
                // First, get all unique dates from both maps
                const allDatesSet = new Set();
                ourDataMap.forEach((data, dateStr) => allDatesSet.add(dateStr));
                ahrefsDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                
                // Convert to array and sort chronologically
                const allDates = Array.from(allDatesSet);
                allDates.sort((a, b) => {
                    const parseDateForSort = (dateStr) => {
                        const parts = dateStr.split(' ');
                        if (parts.length !== 3) return new Date(0);
                        const [month, day, year] = parts;
                        const dateObj = new Date(`${month} ${day}, ${year}`);
                        return isNaN(dateObj.getTime()) ? new Date(0) : dateObj;
                    };
                    return parseDateForSort(a) - parseDateForSort(b);
                });
                
                // Build sorted arrays
                const sortedDates = [];
                const sortedOurData = [];
                const sortedAhrefsData = [];
                
                allDates.forEach(dateStr => {
                    sortedDates.push(dateStr);
                    const ourDataEntry = ourDataMap.get(dateStr);
                    sortedOurData.push(ourDataEntry ? ourDataEntry.value : null);
                    sortedAhrefsData.push(ahrefsDataMap.get(dateStr) || null);
                });
                
                // Debug logging - final summary
                const jul17Idx = sortedDates.findIndex(d => d.includes('Jul 17 2025'));
                const dec24Idx = sortedDates.findIndex(d => d.includes('Dec 24 2025'));
                
                console.log('âœ… Traffic data loaded - FINAL SUMMARY', {
                    totalDates: sortedDates.length,
                    ourDataPoints: sortedOurData.filter(v => v !== null && v !== undefined).length,
                    ahrefsDataPoints: sortedAhrefsData.filter(v => v !== null && v !== undefined).length,
                    ourDataMapSize: ourDataMap.size,
                    ahrefsDataMapSize: ahrefsDataMap.size,
                    firstDate: sortedDates[0],
                    lastDate: sortedDates[sortedDates.length - 1],
                    jul17Data: jul17Idx >= 0 ? {
                        date: sortedDates[jul17Idx],
                        ourValue: sortedOurData[jul17Idx],
                        ahrefsValue: sortedAhrefsData[jul17Idx],
                        match: sortedOurData[jul17Idx] === sortedAhrefsData[jul17Idx]
                    } : 'not found',
                    dec24Data: dec24Idx >= 0 ? {
                        date: sortedDates[dec24Idx],
                        ourValue: sortedOurData[dec24Idx],
                        ahrefsValue: sortedAhrefsData[dec24Idx],
                        match: sortedOurData[dec24Idx] === sortedAhrefsData[dec24Idx]
                    } : 'not found',
                    sampleOurData: sortedOurData.slice(0, 10),
                    sampleAhrefsData: sortedAhrefsData.slice(0, 10),
                    ourDataNonZero: sortedOurData.filter(v => v !== null && v !== undefined && v > 0).length,
                    ahrefsDataNonZero: sortedAhrefsData.filter(v => v !== null && v !== undefined && v > 0).length
                });
                
                // Note: ahrefsData will be empty here - it comes from separate CSV
                // Return empty array for ahrefsData, it will be filled from Ahrefs CSV
                return { dates: sortedDates, ourData: sortedOurData, ahrefsData: [] };
            } catch (error) {
                console.error('Error loading traffic CSV:', error);
                throw error;
            }
        }

        function initializeDashboard(data) {
            domains = data;
            
            // Populate dropdown
            const select = document.getElementById('domainSelect');
            select.innerHTML = '<option value="">Select Domain</option>';
            Object.keys(domains).forEach(domain => {
                const opt = document.createElement('option');
                opt.value = domain;
                opt.textContent = `${domains[domain].rank}. ${domain}`;
                select.appendChild(opt);
            });
            
            // Setup event listener
            setupDomainSelector();
            
            // Auto-select first domain
            if (Object.keys(domains).length > 0) {
                select.value = Object.keys(domains)[0];
                createChart(Object.keys(domains)[0], domains[Object.keys(domains)[0]]);
            }
        }

        async function loadDataFromCSV() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const errorMsg = document.getElementById('error-message');
            const chartsEl = document.getElementById('charts');
            
            // Check if we're on file:// protocol (CSV won't work)
            const isFileProtocol = window.location.protocol === 'file:';
            
            if (isFileProtocol) {
                // Use fallback immediately for file:// protocol
                console.log('File protocol detected - using fallback data');
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
                return;
            }
            
            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                chartsEl.innerHTML = '';
                
                // Set timeout for CSV loading (5 seconds max)
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('CSV loading timeout')), 5000)
                );
                
                const [revenueData, trafficData, ahrefsDataMap] = await Promise.race([
                    Promise.all([loadRevenueCSV(), loadTrafficCSV(), loadAhrefsCSV()]),
                    timeoutPromise
                ]);
                
                // Merge data from all CSVs - use union of all dates
                // Get all unique dates from all datasets (revenue, traffic, ahrefs)
                const allDatesSet = new Set();
                
                // Add revenue dates (monthly, need to convert to daily)
                // Revenue data is monthly, so we'll add the first day of each month
                Object.keys(revenueData).forEach(monthKey => {
                    // monthKey format: "Jan2022" (no space) or "Jan 2022" (with space)
                    // Try to parse both formats
                    let month, year;
                    
                    // Try format "Jan2022" (no space)
                    const noSpaceMatch = monthKey.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{4})$/);
                    if (noSpaceMatch) {
                        [, month, year] = noSpaceMatch;
                    } else {
                        // Try format "Jan 2022" (with space)
                        const parts = monthKey.split(' ');
                        if (parts.length === 2) {
                            [month, year] = parts;
                        } else {
                            return; // Skip if can't parse
                        }
                    }
                    
                    // Add first day of month
                    const dateStr = `${month} 1 ${year}`;
                    allDatesSet.add(dateStr);
                });
                
                // Add traffic dates
                trafficData.dates.forEach(d => allDatesSet.add(d));
                
                // Add Ahrefs dates
                ahrefsDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                
                // Sort all dates chronologically
                const allDates = Array.from(allDatesSet);
                allDates.sort((a, b) => {
                    const parseDateForSort = (dateStr) => {
                        const parts = dateStr.split(' ');
                        if (parts.length !== 3) return new Date(0);
                        const [month, day, year] = parts;
                        const dateObj = new Date(`${month} ${day}, ${year}`);
                        return isNaN(dateObj.getTime()) ? new Date(0) : dateObj;
                    };
                    return parseDateForSort(a) - parseDateForSort(b);
                });
                
                // Build arrays for all dates
                const mergedDates = [];
                const mergedOurData = [];
                const mergedAhrefsData = [];
                
                // Create maps for quick lookup
                const ourDataMap = new Map();
                trafficData.dates.forEach((date, idx) => {
                    ourDataMap.set(date, trafficData.ourData[idx]);
                });
                
                allDates.forEach(dateStr => {
                    mergedDates.push(dateStr);
                    mergedOurData.push(ourDataMap.get(dateStr) || null);
                    mergedAhrefsData.push(ahrefsDataMap.get(dateStr) || null);
                });
                
                // Note: Revenue data is monthly and will be mapped to daily dates in generateMonthlyRevenue()
                // The revenue mapping happens later in createChart() function
                
                // Get rank from CSV (should be 9 for lyncconf.com, but we'll use 1 for display)
                const rank = 1;
                
                domains = {
                    "lyncconf.com": {
                        rank: rank,
                        dates: mergedDates,
                        ourData: mergedOurData,
                        ahrefsData: mergedAhrefsData, // Use Ahrefs data from separate CSV
                        monthlyRevenue: revenueData
                    }
                };
                
                console.log('âœ… Data merged:', {
                    totalDates: mergedDates.length,
                    ourDataPoints: mergedOurData.filter(v => v !== null).length,
                    ahrefsDataPoints: mergedAhrefsData.filter(v => v !== null).length,
                    ahrefsFromCSV: ahrefsDataMap.size,
                    revenueMonths: Object.keys(revenueData).length,
                    firstDate: mergedDates[0],
                    lastDate: mergedDates[mergedDates.length - 1],
                    first10Dates: mergedDates.slice(0, 10),
                    datesWithBothData: mergedDates.filter((d, i) => 
                        mergedOurData[i] !== null && mergedAhrefsData[i] !== null
                    ).length
                });
                
                loadingEl.style.display = 'none';
                initializeDashboard(domains);
            } catch (error) {
                // Fallback to hardcoded data on any error
                console.warn('CSV loading failed, using fallback data:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
            }
        }

        // Initialize on page load - try CSV first, fallback to hardcoded
        loadDataFromCSV();
    </script>
</body>
</html>
