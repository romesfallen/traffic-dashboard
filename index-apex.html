<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="googlebot" content="noindex, nofollow">
    <title>Traffic Dashboard - Premium</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            color: #333333;
            padding: 24px;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #f97316 0%, #fb923c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: #666666;
            font-size: 14px;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        /* Searchable dropdown styles */
        .search-dropdown {
            position: relative;
            min-width: 280px;
        }

        .search-dropdown input {
            width: 100%;
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            cursor: text;
            transition: all 0.2s ease;
        }

        .search-dropdown input:hover {
            border-color: #f97316;
        }

        .search-dropdown input:focus {
            outline: none;
            border-color: #f97316;
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.1);
        }

        .search-dropdown input::placeholder {
            color: #999999;
        }

        .dropdown-list {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: #ffffff;
            border: 1px solid #cccccc;
            border-top: none;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .dropdown-list.open {
            display: block;
        }

        .dropdown-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #333333;
            transition: background 0.15s ease;
        }

        .dropdown-item:hover {
            background: #f5f5f5;
        }

        .dropdown-item.selected {
            background: #fff7ed;
            color: #f97316;
            font-weight: 500;
        }

        .dropdown-item .rank {
            color: #999999;
            font-size: 12px;
            margin-right: 8px;
        }

        .no-results {
            padding: 12px 16px;
            color: #999999;
            font-size: 14px;
            text-align: center;
        }

        .dropdown-item.highlighted {
            background: #f5f5f5;
        }

        .card {
            background: #ffffff;
            border: 1px solid #e5e5e5;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        }

        .stats-row {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #f5f5f5;
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666666;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        .stat-value.positive { color: #4ade80; }
        .stat-value.negative { color: #f87171; }
        .stat-value.neutral { color: #fbbf24; }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333333;
        }

        .chart-subtitle {
            font-size: 13px;
            color: #666666;
        }

        .chart-range-select {
            background: #ffffff;
            border: 1px solid #cccccc;
            color: #333333;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-range-select:hover {
            border-color: #f97316;
            background: #ffffff;
        }

        .chart-range-select:focus {
            outline: none;
            border-color: #f97316;
        }

        #chart-container {
            min-height: 400px;
        }

        .header-stats {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        /* REVENUE LABEL CHANGE: Toggle switch styles */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333333;
        }

        /* View selector toggle group */
        .view-toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #333333;
        }

        .view-toggle-group span {
            margin-right: 4px;
        }

        .view-btn {
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            color: #666666;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-btn:hover {
            border-color: #f97316;
            color: #f97316;
        }

        .view-btn.active {
            background: #f97316;
            border-color: #f97316;
            color: #ffffff;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            background: #cccccc;
            border-radius: 11px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .toggle-switch.active {
            background: #10b981;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .toggle-switch.active::after {
            transform: translateX(18px);
        }

        /* Centered domain title */
        .domain-title-centered {
            text-align: center;
            font-size: 22px;
            font-weight: 600;
            color: #333333;
            margin-bottom: 16px;
        }

        /* Revenue ranking bubbles */
        .ranking-bubbles {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .ranking-bubble {
            display: flex;
            flex-direction: column;
            background: #f5f5f5;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 12px 16px;
            min-width: 140px;
        }

        .ranking-bubble .rank-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .ranking-bubble .rank-number {
            font-weight: 700;
            font-size: 16px;
            color: #f97316;
        }

        .ranking-bubble .rank-label {
            color: #666666;
            font-size: 12px;
        }

        .ranking-bubble .rank-value {
            font-weight: 600;
            font-size: 14px;
            color: #333333;
        }

        .ranking-bubble .rank-pct {
            font-size: 12px;
            color: #10b981;
            font-weight: 500;
        }

        /* Nav link - vertically centered */
        .nav-link {
            display: inline-flex;
            align-items: center;
            color: #f97316;
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
            margin-left: 16px;
            height: 44px;
        }

        .nav-link:hover {
            text-decoration: underline;
        }

        /* User info and sign out */
        .user-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #1f2937;
            color: white;
            padding: 8px 24px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 16px;
            font-size: 13px;
            z-index: 1000;
        }

        .user-bar .user-email {
            color: #d1d5db;
        }

        .user-bar .sign-out {
            color: #f97316;
            text-decoration: none;
            font-weight: 500;
        }

        .user-bar .sign-out:hover {
            text-decoration: underline;
        }

        body {
            padding-top: 56px !important;
        }
    </style>
</head>
<body style="visibility: hidden;">
    <div class="user-bar" id="userBar" style="display: none;">
        <span class="user-email" id="userEmail"></span>
        <a href="/api/auth/logout" class="sign-out">Sign Out</a>
    </div>
    <div class="header">
        <h1>Traffic Comparison Dashboard</h1>
        <p>Our Data vs Ahrefs â€” All Available Data</p>
    </div>

    <!-- REVENUE LABEL CHANGE: Toggle for revenue labels -->
    <div class="header-stats">
        <div class="toggle-container">
            <span>Revenue Labels</span>
            <div class="toggle-switch active" id="revenueLabelToggle"></div>
        </div>
        <div class="view-toggle-group">
            <span>Traffic View:</span>
            <button class="view-btn active" data-view="monthly" id="viewMonthly">Monthly</button>
            <button class="view-btn" data-view="average" id="viewAverage">Average</button>
            <button class="view-btn" data-view="both" id="viewBoth">Both</button>
        </div>
    </div>

    <div class="controls">
        <div class="search-dropdown" id="domainDropdown">
            <input type="text" id="domainSearch" placeholder="Search domains..." autocomplete="off">
            <div class="dropdown-list" id="dropdownList"></div>
        </div>
        <a href="leaderboard.html" class="nav-link">View Leaderboard â†’</a>
    </div>

    <div id="charts"></div>
    <div id="loading" style="display: none; text-align: center; padding: 40px; color: #666666;">
        <div style="font-size: 16px; margin-bottom: 12px;">Loading data...</div>
        <div style="font-size: 13px; color: #999999;">Parsing CSV files</div>
    </div>
    <div id="error" style="display: none; text-align: center; padding: 40px;">
        <div style="background: #fee; border: 1px solid #fcc; border-radius: 12px; padding: 24px; color: #c33;">
            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Data</div>
            <div style="font-size: 13px;" id="error-message"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
        let domains = {};
        
        // REVENUE LABEL CHANGE: Track toggle state, chart instance, and annotations for dynamic update
        let showRevenueLabels = true;
        let currentChart = null;
        let currentAnnotations = [];
        
        // VIEW TOGGLE: Track current view mode (monthly, average, both)
        let currentView = 'monthly';
        let currentDomainData = null;
        let currentDomainName = null;
        
        // Fallback hardcoded data (used if CSV loading fails or for file:// protocol)
        const fallbackData = {
            "lyncconf.com": {
                "rank": 1,
                "dates": ["Jun 4 2025", "Jun 6 2025", "Jun 9 2025", "Jun 11 2025", "Jun 13 2025", "Jun 15 2025", "Jun 16 2025", "Jun 17 2025", "Jun 18 2025", "Jun 19 2025", "Jun 20 2025", "Jun 21 2025", "Jun 22 2025", "Jun 23 2025", "Jun 24 2025", "Jun 25 2025", "Jun 26 2025", "Jun 27 2025", "Jun 28 2025", "Jun 29 2025", "Jun 30 2025", "Jul 1 2025", "Jul 2 2025", "Jul 3 2025", "Jul 4 2025", "Jul 5 2025", "Jul 6 2025", "Jul 7 2025", "Jul 8 2025", "Jul 9 2025", "Jul 10 2025", "Jul 11 2025", "Jul 12 2025", "Jul 13 2025", "Jul 14 2025", "Jul 15 2025", "Jul 16 2025", "Jul 17 2025", "Jul 18 2025", "Jul 19 2025", "Jul 20 2025", "Jul 21 2025", "Jul 22 2025", "Jul 23 2025", "Jul 24 2025", "Jul 25 2025", "Jul 26 2025", "Jul 27 2025", "Jul 28 2025", "Jul 29 2025", "Jul 30 2025", "Jul 31 2025", "Aug 1 2025", "Aug 2 2025", "Aug 3 2025", "Aug 4 2025", "Aug 5 2025", "Aug 6 2025", "Aug 7 2025", "Aug 8 2025", "Aug 9 2025", "Aug 10 2025", "Aug 11 2025", "Aug 12 2025", "Aug 13 2025", "Aug 14 2025", "Aug 15 2025", "Aug 16 2025", "Aug 17 2025", "Aug 18 2025", "Aug 19 2025", "Aug 20 2025", "Aug 21 2025", "Aug 22 2025", "Aug 23 2025", "Aug 24 2025", "Aug 25 2025", "Aug 26 2025", "Aug 27 2025", "Aug 28 2025", "Aug 29 2025", "Aug 30 2025", "Aug 31 2025", "Sep 1 2025", "Sep 2 2025", "Sep 3 2025", "Sep 4 2025", "Sep 5 2025", "Sep 6 2025", "Sep 7 2025", "Sep 8 2025", "Sep 9 2025", "Sep 10 2025", "Sep 11 2025", "Sep 12 2025", "Sep 13 2025", "Sep 14 2025", "Sep 15 2025", "Sep 16 2025", "Sep 17 2025", "Sep 18 2025", "Sep 19 2025", "Sep 20 2025", "Sep 21 2025", "Sep 22 2025", "Sep 23 2025", "Sep 24 2025", "Sep 25 2025", "Sep 26 2025", "Sep 27 2025", "Sep 28 2025", "Sep 29 2025", "Sep 30 2025", "Oct 1 2025", "Oct 2 2025", "Oct 3 2025", "Oct 4 2025", "Oct 5 2025", "Oct 6 2025", "Oct 7 2025", "Oct 8 2025", "Oct 9 2025", "Oct 10 2025", "Oct 11 2025", "Oct 12 2025", "Oct 13 2025", "Oct 14 2025", "Oct 15 2025", "Oct 16 2025", "Oct 17 2025", "Oct 18 2025", "Oct 19 2025", "Oct 20 2025", "Oct 21 2025", "Oct 22 2025", "Oct 23 2025", "Oct 24 2025", "Oct 25 2025", "Oct 26 2025", "Oct 27 2025", "Oct 28 2025", "Oct 29 2025", "Oct 30 2025", "Oct 31 2025", "Nov 1 2025", "Nov 2 2025", "Nov 3 2025", "Nov 4 2025", "Nov 5 2025", "Nov 6 2025", "Nov 7 2025", "Nov 8 2025", "Nov 9 2025", "Nov 10 2025", "Nov 11 2025", "Nov 12 2025", "Nov 13 2025", "Nov 14 2025", "Nov 15 2025", "Nov 16 2025", "Nov 17 2025", "Nov 18 2025", "Nov 19 2025", "Nov 20 2025", "Nov 21 2025", "Nov 22 2025", "Nov 23 2025", "Nov 24 2025", "Nov 25 2025", "Nov 26 2025", "Nov 27 2025", "Nov 28 2025", "Nov 29 2025", "Nov 30 2025", "Dec 1 2025", "Dec 2 2025", "Dec 3 2025", "Dec 4 2025", "Dec 5 2025", "Dec 6 2025", "Dec 7 2025", "Dec 8 2025", "Dec 9 2025", "Dec 10 2025", "Dec 11 2025", "Dec 12 2025", "Dec 13 2025", "Dec 14 2025", "Dec 15 2025", "Dec 16 2025", "Dec 17 2025", "Dec 18 2025", "Dec 19 2025", "Dec 20 2025", "Dec 21 2025", "Dec 22 2025", "Dec 23 2025", "Dec 24 2025", "Dec 25 2025", "Dec 26 2025", "Dec 27 2025", "Dec 28 2025", "Dec 29 2025", "Dec 30 2025", "Dec 31 2025", "Jan 1 2026", "Jan 2 2026", "Jan 3 2026", "Jan 4 2026", "Jan 5 2026", "Jan 6 2026", "Jan 7 2026", "Jan 8 2026", "Jan 9 2026", "Jan 10 2026", "Jan 11 2026", "Jan 12 2026", "Jan 13 2026"],
                "ourData": [21181, 12214, 14683, 14853, 14853, 15828, 16243, 15436, 14741, 14591, 14727, 13648, 13652, 13630, 12950, 12785, 12250, 12168, 12758, 14113, 13908, 14377, 15564, 15544, 31400, 18697, 17470, 17697, 17702, 17436, 17045, null, null, null, 16256, 15751, 16753, 16786, 18064, 18444, 18560, 18826, 18574, 17890, null, 17453, 17140, 17515, 17472, 17966, 17692, 17796, 17788, 17691, 17966, 18013, 17807, 18917, 18062, 19593, 19893, 19857, 20241, 21025, 20957, 20979, 20757, 21519, 21324, 21689, 21238, 22351, 22236, 22078, 22354, 22372, 22572, 22134, 25845, 25669, 25275, 25641, 25896, 27240, 26132, 25311, 27678, 26710, 22632, 22060, 21772, 20044, 19439, 20014, 20337, 20468, 22754, 22839, 22863, 22027, 23249, 23045, 20593, 20627, 19835, 19944, 20549, 22075, 22146, 21869, 22935, 22359, 21876, 21857, 22162, 21277, 20967, 20787, 21752, 21080, 21134, 35709, 34312, 39097, 38726, 38991, 38769, 38588, 38377, 42276, 41954, 41584, 42779, 42335, 41994, 41333, 41222, 41196, 41253, 41331, 40501, 40914, 39037, 36227, 35709, 36243, 37719, 37708, 37206, 37153, 36398, 35574, 34636, 34273, 33938, 33092, 33291, 37877, 37846, 40497, 41423, 37901, 37756, 34484, 32813, 32759, 31730, 31411, 31133, 35860, 35727, 35466, 35534, 33597, 33725, 33969, 33876, 33239, 29435, 29435, 29435, 29499, 29318, 29332, 29060, 29056, 33879, 32360, 31831, 32154, 31830, 32360, 32273, 30332, 26822, 25631, 25645, 27155, 26979, 27054, 28928, 28757, 29755, 29266, 29757, 29253, 29255, 33132, 33346, 33206, 33196, 31908, 31758, 31450, 31720, 31528, 31688, 33221],
                "ahrefsData": [17528, 17527, 17186, 17523, 18024, 17792, 17977, 17593, 17404, 17257, 17189, 17204, 17218, 17231, 16822, 16528, 16154, 16641, 16946, 17137, 17012, 17271, 18026, 17927, 18299, 17851, 17701, 17802, 17731, 17337, 16765, 16442, 15874, 15386, 15074, 14772, 14817, 14566, 14575, 14401, 14444, 14705, 14532, 14530, 14220, 14379, 14276, 14016, 13828, 14019, 14058, 14039, 14200, 14291, 14674, 15683, 16767, 16973, 16861, 16951, 17571, 17970, 17935, 18359, 18498, 17629, 18192, 18461, 18206, 18342, 18807, 18556, 18453, 18828, 18855, 18331, 18499, 18902, 19215, 19260, 18655, 18479, 19183, 26261, 27209, 31515, 32057, 37858, 39789, 41136, 43910, 43490, 44102, 44949, 49039, 53254, 54810, 55483, 55860, 59064, 59505, 60087, 59502, 59714, 61523, 62437, 66084, 66295, 65929, 66803, 67012, 66667, 65457, 65294, 77416, 78362, 80187, 82054, 82102, 83507, 85663, 85012, 84857, 87302, 86783, 90198, 89738, 89679, 89303, 89287, 88653, 89210, 89792, 89049, 89206, 89521, 89308, 89491, 89589, 89437, 90023, 87930, 87415, 87761, 87824, 83780, 80815, 81108, 81137, 80606, 78352, 76677, 75936, 74946, 75697, 75902, 72775, 72194, 71603, 72297, 63810, 64307, 62909, 61219, 59119, 59079, 59178, 58832, 58824, 58272, 58092, 57793, 56335, 55104, 54808, 54797, 52267, 49815, 49815, 49815, 49804, 49030, 47758, 47372, 47377, 47392, 44775, 43091, 44252, 43685, 44094, 44010, 41503, 39458, 37858, 37163, 37451, 37281, 37832, 37197, 37162, 36846, 35246, 34897, 34439, 34555, 34444, 34729, 34686, 34582, 33974, 33946, 33551, 33270, 33193, 33178, 33322, 33180],
                "drData": [67, 67, 67, 68, 68, 69, 70, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 71, 72, 72, 72, 71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 70, 70, 70, 70, 70, 70, 70, 70, 70, 69, 70, 70, 70, 69, 69, 69, 69, 69, 69, 68, 68, 68, 68, 68, 68, 68, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71],
                "internalAvgData": [],
                "ahrefsAvgData": [],
                "ourChange": "+56.8%",
                "ahrefsChange": "+89.3%",
                "revenueRankings": {
                    "lifetime": 1,
                    "last3Month": 1,
                    "currentMonth": 1,
                    "lifetimeValue": 351788,
                    "last3MonthValue": 19585,
                    "currentMonthValue": 3630,
                    "lifetimePct": "100.0",
                    "last3MonthPct": "100.0",
                    "currentMonthPct": "100.0"
                }
            }
        };

        function getStatClass(value) {
            const num = parseFloat(value);
            if (num > 5) return 'positive';
            if (num < -5) return 'negative';
            return 'neutral';
        }

        // Linear interpolation for missing data
        function interpolateData(arr) {
            const real = [...arr];
            const estimated = new Array(arr.length).fill(null);
            const isEstimated = new Array(arr.length).fill(false);
            
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === null) {
                    let prevIdx = i - 1;
                    while (prevIdx >= 0 && arr[prevIdx] === null) prevIdx--;
                    
                    let nextIdx = i + 1;
                    while (nextIdx < arr.length && arr[nextIdx] === null) nextIdx++;
                    
                    if (prevIdx >= 0 && nextIdx < arr.length) {
                        const prevVal = arr[prevIdx];
                        const nextVal = arr[nextIdx];
                        const steps = nextIdx - prevIdx;
                        const step = (nextVal - prevVal) / steps;
                        const interpolated = Math.round(prevVal + step * (i - prevIdx));
                        
                        real[i] = interpolated;
                        estimated[i] = interpolated;
                        isEstimated[i] = true;
                    }
                }
            }
            
            return { real, estimated, isEstimated };
        }

        // Calculate x-axis range for initial zoom (returns min/max timestamps)
        // Returns null for 'all' to show full range
        function getDateRangeBounds(data, days) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Helper to parse date string to timestamp
            function parseDateStr(dateStr) {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return null;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return null;
                return new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
            }
            
            if (days === 'all' || !data.dates || data.dates.length === 0) {
                return { min: undefined, max: undefined };
            }
            
            // Get the last date's timestamp for max bound
            const lastDate = data.dates[data.dates.length - 1];
            const maxTimestamp = parseDateStr(lastDate);
            
            // Special case: From December 2024
            if (days === 'dec2024') {
                const startDate = new Date(2024, 11, 1); // Dec 1, 2024
                return { min: startDate.getTime(), max: maxTimestamp };
            }
            
            // For numeric days (7, 30, 90, etc.), calculate start from end
            const numDays = parseInt(days);
            if (isNaN(numDays) || !maxTimestamp) {
                return { min: undefined, max: undefined };
            }
            
            const minTimestamp = maxTimestamp - (numDays * 24 * 60 * 60 * 1000);
            return { min: minTimestamp, max: maxTimestamp };
        }
        
        // Filter data by date range (kept for backwards compatibility but returns all data)
        function filterByDateRange(data, days) {
            // Always return ALL data - zoom range is controlled by xaxis min/max
            return {
                dates: data.dates,
                ourData: data.ourData,
                ahrefsData: data.ahrefsData,
                drData: data.drData || []
            };
        }

        // REVENUE LABEL CHANGE: Modified to also return annotation data for labels
        // Generate monthly revenue with strict normalization and timestamp-based stepped blocks
        function generateMonthlyRevenue(dates, monthlyRevenueData = null) {
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Use CSV data if provided, otherwise use default
            const monthRevenue = monthlyRevenueData || {
                'Jun2025': 100, 'Jul2025': 200, 'Aug2025': 300, 'Sep2025': 400,
                'Oct2025': 500, 'Nov2025': 600, 'Dec2025': 700, 'Jan2026': 800
            };
            
            // Helper: Parse "Jan 1 2024" to timestamp
            function parseDateToTimestamp(dateStr) {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return null;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return null;
                return new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
            }
            
            // STEP 1: Normalize & De-Duplicate by YYYY-MM
            // Create a Map keyed by YYYY-MM, keeping latest value per month
            const normalizedMap = new Map();
            
            // First, extract unique months from dates array
            dates.forEach(dateStr => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                const [month, day, year] = parts;
                const monthIndex = monthNames.indexOf(month);
                if (monthIndex === -1) return;
                
                // Key: YYYY-MM format for sorting
                const key = `${year}-${String(monthIndex + 1).padStart(2, '0')}`;
                // Revenue key format: "Jun2025"
                const revenueKey = month + year;
                const revenueValue = monthRevenue[revenueKey] || 0;
                
                // Keep latest value (overwrites if exists)
                normalizedMap.set(key, {
                    year: parseInt(year),
                    monthIndex: monthIndex,
                    month: month,
                    revenue: revenueValue
                });
            });
            
            // Sort keys chronologically
            const sortedKeys = Array.from(normalizedMap.keys()).sort();
            
            // STEP 2: Generate Stepped Area Blocks (3 points per month)
            const revenuePoints = [];
            
            // REVENUE LABEL CHANGE: Also build annotations array for point annotations
            const revenueAnnotations = [];
            
            sortedKeys.forEach(key => {
                const info = normalizedMap.get(key);
                const revenue = info.revenue;
                
                // Start Date: 1st of the month
                const startDate = new Date(info.year, info.monthIndex, 1);
                
                // End Date: Start + 25 days
                const endDate = new Date(info.year, info.monthIndex, 26); // Day 26
                
                // Cut Date: Start + 26 days (creates sharp drop)
                const cutDate = new Date(info.year, info.monthIndex, 27); // Day 27
                
                // Push 3 points for stepped area
                revenuePoints.push({ x: startDate.getTime(), y: revenue });
                revenuePoints.push({ x: endDate.getTime(), y: revenue });
                revenuePoints.push({ x: cutDate.getTime(), y: 0 });
                
                // REVENUE LABEL CHANGE: Create point annotation at center of bar (day 13)
                // Only add annotation if revenue > 0
                if (revenue > 0) {
                    const midDate = new Date(info.year, info.monthIndex, 13);
                    revenueAnnotations.push({
                        x: midDate.getTime(),
                        y: revenue,
                        label: '$' + revenue.toLocaleString(),
                        month: info.month,
                        year: info.year
                    });
                }
            });
            
            // SAFETY CHECK: Sort by timestamp
            revenuePoints.sort((a, b) => a.x - b.x);
            
            // Log for verification
            console.log('ðŸ“Š Revenue Data Processed:', {
                uniqueMonths: sortedKeys.length,
                totalPoints: revenuePoints.length,
                expectedPoints: sortedKeys.length * 3,
                firstMonth: sortedKeys[0],
                lastMonth: sortedKeys[sortedKeys.length - 1],
                samplePoints: revenuePoints.slice(0, 6),
                annotations: revenueAnnotations.length // REVENUE LABEL CHANGE
            });
            
            // Also generate categories array for x-axis labels (mid-month positioned)
            const categories = new Array(dates.length).fill(' ');
            
            // Find mid-month indices for labels
            const monthIndices = {};
            dates.forEach((dateStr, idx) => {
                const parts = dateStr.split(' ');
                if (parts.length !== 3) return;
                const [month, day, year] = parts;
                const key = month + year;
                if (!monthIndices[key]) {
                    monthIndices[key] = { firstIdx: idx, lastIdx: idx, month, year };
                } else {
                    monthIndices[key].lastIdx = idx;
                }
            });
            
            Object.entries(monthIndices).forEach(([key, info]) => {
                const midIdx = Math.floor((info.firstIdx + info.lastIdx) / 2);
                categories[midIdx] = info.month + ' ' + info.year;
            });
            
            // REVENUE LABEL CHANGE: Return annotations array as well
            return { revenuePoints, categories, revenueAnnotations };
        }

        // Calculate change percentage for filtered data
        function calcChange(arr) {
            const validData = arr.filter(v => v !== null && v !== undefined);
            if (validData.length < 2) return 'N/A';
            const first = validData[0];
            const last = validData[validData.length - 1];
            const change = ((last - first) / first * 100).toFixed(1);
            return (change >= 0 ? '+' : '') + change + '%';
        }

        function createChart(domain, data, dateRange = 'dec2024') {
            // REVENUE LABEL CHANGE: Destroy previous chart if exists
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            // VIEW TOGGLE: Store current domain info for view toggles
            currentDomainData = data;
            currentDomainName = domain;
            
            const chartsDiv = document.getElementById('charts');
            chartsDiv.innerHTML = '';

            const filtered = filterByDateRange(data, dateRange);

            const card = document.createElement('div');
            card.className = 'card';

            // Get revenue rankings (with fallback defaults)
            const rankings = data.revenueRankings || { 
                lifetime: '-', last3Month: '-', currentMonth: '-',
                lifetimeValue: 0, last3MonthValue: 0, currentMonthValue: 0,
                lifetimePct: 0, last3MonthPct: 0, currentMonthPct: 0
            };
            
            // Format currency
            const formatCurrency = (val) => '$' + Math.round(val).toLocaleString();
            
            card.innerHTML = `
                <div class="domain-title-centered">${domain}</div>
                <div class="ranking-bubbles">
                    <div class="ranking-bubble">
                        <div class="rank-header">
                            <span class="rank-number">#${rankings.lifetime}</span>
                            <span class="rank-label">Lifetime Revenue</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.lifetimeValue)}</div>
                        <div class="rank-pct">${rankings.lifetimePct}% of portfolio</div>
                    </div>
                    <div class="ranking-bubble">
                        <div class="rank-header">
                            <span class="rank-number">#${rankings.last3Month}</span>
                            <span class="rank-label">Last 3 Months</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.last3MonthValue)}</div>
                        <div class="rank-pct">${rankings.last3MonthPct}% of portfolio</div>
                    </div>
                    <div class="ranking-bubble">
                        <div class="rank-header">
                            <span class="rank-number">#${rankings.currentMonth}</span>
                            <span class="rank-label">Current Month</span>
                        </div>
                        <div class="rank-value">${formatCurrency(rankings.currentMonthValue)}</div>
                        <div class="rank-pct">${rankings.currentMonthPct}% of portfolio</div>
                    </div>
                </div>
                <div class="chart-header">
                    <div></div>
                    <select class="chart-range-select" id="chartDateRange">
                        <option value="7" ${dateRange === '7' ? 'selected' : ''}>Last 7 days</option>
                        <option value="30" ${dateRange === '30' ? 'selected' : ''}>Last month</option>
                        <option value="90" ${dateRange === '90' ? 'selected' : ''}>Last 3 months</option>
                        <option value="180" ${dateRange === '180' ? 'selected' : ''}>Last 6 months</option>
                        <option value="365" ${dateRange === '365' ? 'selected' : ''}>Last year</option>
                        <option value="dec2024" ${dateRange === 'dec2024' ? 'selected' : ''}>From Dec 2024</option>
                        <option value="all" ${dateRange === 'all' ? 'selected' : ''}>All time</option>
                    </select>
                </div>
                <div id="apex-chart"></div>
            `;
            chartsDiv.appendChild(card);

            document.getElementById('chartDateRange').addEventListener('change', function() {
                createChart(domain, data, this.value);
            });

            const ourProcessed = interpolateData(filtered.ourData);
            const ahrefsProcessed = interpolateData(filtered.ahrefsData);
            const drProcessed = interpolateData(filtered.drData || []);
            const internalAvgProcessed = interpolateData(data.internalAvgData || []);
            const ahrefsAvgProcessed = interpolateData(data.ahrefsAvgData || []);
            const revenueResult = generateMonthlyRevenue(filtered.dates, data.monthlyRevenue);
            
            // Get x-axis bounds for initial zoom (allows zooming out beyond this range)
            const xAxisBounds = getDateRangeBounds(data, dateRange);
            
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Convert traffic data to timestamp-based {x, y} format
            function convertToTimestampData(dates, values) {
                return dates.map((dateStr, idx) => {
                    const parts = dateStr.split(' ');
                    if (parts.length !== 3) return null;
                    const [month, day, year] = parts;
                    const monthIndex = monthNames.indexOf(month);
                    if (monthIndex === -1) return null;
                    const timestamp = new Date(parseInt(year), monthIndex, parseInt(day)).getTime();
                    return { x: timestamp, y: values[idx] };
                }).filter(p => p !== null);
            }
            
            const ourDataPoints = convertToTimestampData(filtered.dates, ourProcessed.real);
            const ahrefsDataPoints = convertToTimestampData(filtered.dates, ahrefsProcessed.real);
            const drDataPoints = convertToTimestampData(filtered.dates, drProcessed.real);
            const internalAvgDataPoints = convertToTimestampData(filtered.dates, internalAvgProcessed.real);
            const ahrefsAvgDataPoints = convertToTimestampData(filtered.dates, ahrefsAvgProcessed.real);
            const revenuePoints = revenueResult.revenuePoints;
            
            // Calculate max revenue for "bottom-third" axis scaling
            const maxRevenue = Math.max(...revenuePoints.map(p => p.y || 0), 1);
            const revenueAxisMax = maxRevenue * 3;
            
            // REVENUE LABEL CHANGE: Build point annotations and store globally for toggle
            currentAnnotations = revenueResult.revenueAnnotations.map(ann => ({
                x: ann.x,
                y: ann.y,
                yAxisIndex: 2, // Revenue y-axis
                seriesIndex: 2, // Revenue series
                marker: {
                    size: 0 // Hide the marker dot
                },
                label: {
                    borderColor: 'transparent',
                    borderWidth: 0,
                    text: ann.label,
                    style: {
                        background: 'transparent',
                        color: '#047857', // Dark green for visibility
                        fontSize: '10px',
                        fontWeight: 600,
                        fontFamily: 'Inter, sans-serif',
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    offsetY: 25, // Push label down toward bottom of bar
                    offsetX: 0
                }
            }));
            
            // Use annotations based on current toggle state
            const pointAnnotations = showRevenueLabels ? currentAnnotations : [];

            // VIEW TOGGLE: Determine which series to show based on currentView
            const showMonthly = currentView === 'monthly' || currentView === 'both';
            const showAverage = currentView === 'average' || currentView === 'both';
            
            // Build series array based on view
            const allSeries = [];
            
            // Monthly series (indices 0, 1)
            if (showMonthly) {
                allSeries.push({
                    name: 'Internal Monthly Traffic',
                    type: 'area',
                    data: ourDataPoints
                });
                allSeries.push({
                    name: 'Ahrefs Monthly Traffic',
                    type: 'area',
                    data: ahrefsDataPoints
                });
            }
            
            // Average series (indices 2, 3 when monthly hidden, or 4, 5 when both shown)
            if (showAverage) {
                allSeries.push({
                    name: 'Internal Average Traffic',
                    type: 'area',
                    data: internalAvgDataPoints
                });
                allSeries.push({
                    name: 'Ahrefs Average Traffic',
                    type: 'area',
                    data: ahrefsAvgDataPoints
                });
            }
            
            // Revenue always shown
            allSeries.push({
                name: 'Revenue',
                type: 'area',
                data: revenuePoints
            });
            
            // DR always shown
            allSeries.push({
                name: 'DR',
                type: 'line',
                data: drDataPoints
            });
            
            // Build colors array based on visible series
            const allColors = [];
            if (showMonthly) {
                allColors.push('#f97316'); // Internal Monthly - Orange
                allColors.push('#3b82f6'); // Ahrefs Monthly - Blue
            }
            if (showAverage) {
                allColors.push('#ef4444'); // Internal Average - Red
                allColors.push('#06b6d4'); // Ahrefs Average - Cyan
            }
            allColors.push('#10b981'); // Revenue - Green
            allColors.push('#a855f7'); // DR - Purple
            
            // Build stroke config based on visible series
            const strokeCurve = [];
            const strokeWidth = [];
            const strokeDash = [];
            const fillOpacity = [];
            
            if (showMonthly) {
                strokeCurve.push('smooth', 'smooth');
                strokeWidth.push(2, 2);
                strokeDash.push(0, 0);
                fillOpacity.push(0, 0);
            }
            if (showAverage) {
                strokeCurve.push('smooth', 'smooth');
                strokeWidth.push(2, 2);
                strokeDash.push(0, 0); // Solid lines for average (matches monthly)
                fillOpacity.push(0, 0);
            }
            // Revenue
            strokeCurve.push('stepline');
            strokeWidth.push(0);
            strokeDash.push(0);
            fillOpacity.push(0.25);
            // DR
            strokeCurve.push('straight');
            strokeWidth.push(3);
            strokeDash.push(6);
            fillOpacity.push(0);
            
            const options = {
                series: allSeries,
                chart: {
                    type: 'line',
                    height: 480,
                    background: 'transparent',
                    toolbar: { 
                        show: true, 
                        tools: { 
                            download: true, 
                            zoom: true, 
                            zoomin: true,
                            zoomout: true,
                            pan: true,
                            reset: true // Home icon to reset to initial zoom
                        }
                    },
                    zoom: {
                        enabled: true,
                        type: 'x', // Allow zooming on x-axis
                        autoScaleYaxis: true // Auto-adjust y-axis when zooming
                    },
                    animations: {
                        enabled: true,
                        easing: 'easeinout',
                        speed: 800
                    },
                    stacked: false
                },
                // REVENUE LABEL CHANGE: Add annotations section
                annotations: {
                    points: pointAnnotations
                },
                colors: allColors,
                fill: {
                    type: allSeries.map(() => 'solid'),
                    opacity: fillOpacity
                },
                stroke: {
                    curve: strokeCurve,
                    width: strokeWidth,
                    dashArray: strokeDash
                },
                markers: {
                    size: allSeries.map((s, i) => s.name === 'DR' ? 2 : 0), // Small markers for DR only
                    hover: { size: 5 },
                    strokeWidth: 0
                },
                xaxis: {
                    type: 'datetime',
                    min: xAxisBounds.min, // Initial zoom start (undefined = auto)
                    max: xAxisBounds.max, // Initial zoom end (undefined = auto)
                    labels: {
                        style: { colors: '#333333', fontSize: '11px', fontWeight: 500 },
                        rotate: 0,
                        rotateAlways: false,
                        hideOverlappingLabels: true,
                        datetimeUTC: false,
                        format: 'MMM yyyy',
                        offsetX: 15, // Nudge labels right to center on Day 1-25 blocks
                        datetimeFormatter: {
                            year: 'yyyy',
                            month: 'MMM yyyy',
                            day: 'dd MMM',
                            hour: 'HH:mm'
                        }
                    },
                    axisBorder: { color: '#cccccc' },
                    axisTicks: { show: false },
                    crosshairs: {
                        show: true,
                        stroke: { color: '#999999', width: 1, dashArray: 3 }
                    },
                    tooltip: { enabled: true, format: 'dd MMM yyyy' }
                },
                yaxis: (() => {
                    // Build y-axis config dynamically based on visible series
                    const yaxisConfig = [];
                    
                    // First traffic series gets the main left axis
                    let firstTrafficAxis = true;
                    
                    if (showMonthly) {
                        // Internal Monthly Traffic - Left Axis (Primary)
                        yaxisConfig.push({
                            seriesName: 'Internal Monthly Traffic',
                            title: firstTrafficAxis ? {
                                text: 'Traffic',
                                style: { color: '#333333', fontSize: '12px' }
                            } : undefined,
                            show: firstTrafficAxis,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                        firstTrafficAxis = false;
                        
                        // Ahrefs Monthly - shares axis
                        yaxisConfig.push({
                            seriesName: 'Ahrefs Monthly Traffic',
                            show: false,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                    }
                    
                    if (showAverage) {
                        // Internal Average Traffic
                        yaxisConfig.push({
                            seriesName: 'Internal Average Traffic',
                            title: firstTrafficAxis ? {
                                text: 'Traffic',
                                style: { color: '#333333', fontSize: '12px' }
                            } : undefined,
                            show: firstTrafficAxis,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                        firstTrafficAxis = false;
                        
                        // Ahrefs Average - shares axis
                        yaxisConfig.push({
                            seriesName: 'Ahrefs Average Traffic',
                            show: false,
                            labels: {
                                style: { colors: '#333333' },
                                formatter: val => val ? val.toLocaleString() : ''
                            },
                            min: 0
                        });
                    }
                    
                    // Revenue - Right Axis
                    yaxisConfig.push({
                        seriesName: 'Revenue',
                        opposite: true,
                        title: {
                            text: 'Revenue ($)',
                            style: { color: '#10b981', fontSize: '12px' }
                        },
                        labels: {
                            style: { colors: '#10b981' },
                            formatter: val => val ? '$' + val.toLocaleString() : ''
                        },
                        min: 0,
                        max: revenueAxisMax
                    });
                    
                    // DR - Right Axis B
                    yaxisConfig.push({
                        seriesName: 'DR',
                        opposite: true,
                        title: {
                            text: 'DR',
                            style: { color: '#a855f7', fontSize: '12px' },
                            offsetX: -10
                        },
                        labels: {
                            style: { colors: '#a855f7' },
                            formatter: val => val ? val.toFixed(0) : '',
                            offsetX: -10
                        },
                        min: 0,
                        max: 100,
                        tickAmount: 5,
                        axisBorder: {
                            show: true,
                            color: '#a855f7',
                            offsetX: -5
                        }
                    });
                    
                    return yaxisConfig;
                })(),
                grid: {
                    borderColor: '#e8e8e8',
                    strokeDashArray: 0,
                    padding: {
                        left: 20,
                        right: 40, // Extra space for DR axis
                        bottom: 15
                    }
                },
                legend: {
                    position: 'top',
                    horizontalAlign: 'left',
                    offsetY: 0,
                    labels: { colors: '#333333' },
                    markers: { width: 10, height: 10, radius: 10 }
                },
                tooltip: {
                    enabled: true,
                    shared: true,
                    intersect: false,
                    followCursor: true,
                    fixed: {
                        enabled: false
                    },
                    custom: function({ series, seriesIndex, dataPointIndex, w }) {
                        // Get the x value (timestamp) from the HOVERED series
                        const hoveredSeriesData = w.config.series[seriesIndex].data;
                        const hoveredPoint = hoveredSeriesData[dataPointIndex];
                        const xValue = hoveredPoint?.x;
                        
                        if (!xValue) return '';
                        
                        const date = new Date(xValue);
                        const dateStr = date.toLocaleDateString('en-GB', { 
                            day: 'numeric', 
                            month: 'short', 
                            year: 'numeric' 
                        });
                        
                        let html = '<div class="apexcharts-tooltip-custom" style="padding: 10px; background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.12);">';
                        html += '<div style="font-weight: 600; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #eee; color: #333;">' + dateStr + '</div>';
                        
                        // Loop through all visible series dynamically
                        const seriesCount = w.config.series.length;
                        const seriesColors = w.config.colors;
                        
                        for (let i = 0; i < seriesCount; i++) {
                            const seriesData = w.config.series[i].data;
                            const seriesName = w.config.series[i].name;
                            const seriesColor = seriesColors[i];
                            let value = null;
                            
                            // Find the closest point by timestamp
                            let closestDiff = Infinity;
                            const isRevenue = seriesName === 'Revenue';
                            const maxDiff = isRevenue ? 20 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000;
                            
                            for (let j = 0; j < seriesData.length; j++) {
                                const point = seriesData[j];
                                if (point && point.x !== undefined) {
                                    const diff = Math.abs(point.x - xValue);
                                    if (diff < closestDiff && diff <= maxDiff) {
                                        closestDiff = diff;
                                        value = point.y;
                                    }
                                }
                            }
                            
                            // Format value based on series type
                            let displayValue = 'â€”';
                            if (value !== null && value !== undefined) {
                                if (seriesName === 'Revenue') {
                                    displayValue = '$' + value.toLocaleString();
                                } else if (seriesName === 'DR') {
                                    displayValue = value.toFixed(0);
                                } else if (value !== 0) {
                                    displayValue = value.toLocaleString() + ' visits';
                                }
                            }
                            
                            // Skip if no data found
                            if (value === null) {
                                continue;
                            }
                            
                            html += '<div style="display: flex; align-items: center; padding: 4px 0;">';
                            html += '<span style="width: 10px; height: 10px; border-radius: 50%; background: ' + seriesColor + '; margin-right: 8px;"></span>';
                            html += '<span style="color: #666; min-width: 140px;">' + seriesName + ':</span>';
                            html += '<span style="font-weight: 600; color: #333; margin-left: auto;">' + displayValue + '</span>';
                            html += '</div>';
                        }
                        
                        html += '</div>';
                        return html;
                    }
                },
                dataLabels: { enabled: false }
            };

            const chart = new ApexCharts(document.querySelector('#apex-chart'), options);
            chart.render();
            
            // REVENUE LABEL CHANGE: Store chart instance for dynamic updates
            currentChart = chart;
            
            // Make tooltip follow cursor on Y axis
            const chartEl = document.querySelector('#apex-chart');
            chartEl.addEventListener('mousemove', function(e) {
                const tooltip = chartEl.querySelector('.apexcharts-tooltip');
                if (tooltip && tooltip.classList.contains('apexcharts-active')) {
                    const chartRect = chartEl.getBoundingClientRect();
                    const mouseY = e.clientY - chartRect.top;
                    const tooltipHeight = tooltip.offsetHeight;
                    
                    // Position tooltip near cursor Y, with some offset
                    let newTop = mouseY - tooltipHeight / 2;
                    
                    // Keep within chart bounds
                    newTop = Math.max(10, Math.min(newTop, chartRect.height - tooltipHeight - 10));
                    
                    tooltip.style.top = newTop + 'px';
                }
            });
        }

        // Searchable dropdown functionality
        let selectedDomain = null;
        
        function setupDomainSelector() {
            const input = document.getElementById('domainSearch');
            const dropdownList = document.getElementById('dropdownList');
            
            // Build dropdown items
            function renderDropdown(filter = '') {
                const filterLower = filter.toLowerCase();
                const filtered = Object.keys(domains).filter(domain => 
                    domain.toLowerCase().includes(filterLower)
                );
                
                if (filtered.length === 0) {
                    dropdownList.innerHTML = '<div class="no-results">No domains found</div>';
                } else {
                    dropdownList.innerHTML = filtered.map(domain => {
                        const isSelected = domain === selectedDomain;
                        return `<div class="dropdown-item${isSelected ? ' selected' : ''}" data-domain="${domain}">
                            <span class="rank">${domains[domain].rank}.</span>${domain}
                        </div>`;
                    }).join('');
                }
            }
            
            // Show dropdown on focus - select all text and show full list
            input.addEventListener('focus', function() {
                this.select(); // Select all text so typing replaces it
                renderDropdown(''); // Show all domains, not filtered by current value
                dropdownList.classList.add('open');
            });
            
            // Filter on input
            input.addEventListener('input', function() {
                renderDropdown(this.value);
                dropdownList.classList.add('open');
            });
            
            // Handle item click
            dropdownList.addEventListener('click', function(e) {
                const item = e.target.closest('.dropdown-item');
                if (item) {
                    const domain = item.dataset.domain;
                    selectedDomain = domain;
                    input.value = domain;
                    dropdownList.classList.remove('open');
                    
                    if (domains[domain]) {
                        createChart(domain, domains[domain]);
                    }
                }
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-dropdown')) {
                    dropdownList.classList.remove('open');
                }
            });
            
            // Keyboard navigation
            input.addEventListener('keydown', function(e) {
                const items = dropdownList.querySelectorAll('.dropdown-item');
                const currentIndex = Array.from(items).findIndex(item => item.classList.contains('highlighted'));
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    items.forEach(item => item.classList.remove('highlighted'));
                    const nextIndex = currentIndex < items.length - 1 ? currentIndex + 1 : 0;
                    items[nextIndex]?.classList.add('highlighted');
                    items[nextIndex]?.scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    items.forEach(item => item.classList.remove('highlighted'));
                    const prevIndex = currentIndex > 0 ? currentIndex - 1 : items.length - 1;
                    items[prevIndex]?.classList.add('highlighted');
                    items[prevIndex]?.scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    const highlighted = dropdownList.querySelector('.dropdown-item.highlighted');
                    if (highlighted) {
                        highlighted.click();
                    } else if (items.length > 0) {
                        items[0].click();
                    }
                } else if (e.key === 'Escape') {
                    dropdownList.classList.remove('open');
                    input.blur();
                }
            });
        }

        // REVENUE LABEL CHANGE: Setup toggle event listener with dynamic update (no re-render)
        function setupRevenueToggle() {
            const toggle = document.getElementById('revenueLabelToggle');
            toggle.addEventListener('click', function() {
                showRevenueLabels = !showRevenueLabels;
                this.classList.toggle('active', showRevenueLabels);
                
                // Update chart annotations dynamically without full re-render
                if (currentChart) {
                    currentChart.updateOptions({
                        annotations: {
                            points: showRevenueLabels ? currentAnnotations : []
                        }
                    }, false, false); // redrawPaths=false, animate=false for instant toggle
                }
            });
        }
        
        // VIEW TOGGLE: Setup view toggle buttons (Monthly / Average / Both)
        function setupViewToggle() {
            const buttons = document.querySelectorAll('.view-btn');
            
            buttons.forEach(btn => {
                btn.addEventListener('click', function() {
                    const newView = this.dataset.view;
                    if (newView === currentView) return; // No change
                    
                    // Update active state
                    buttons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update current view
                    currentView = newView;
                    
                    // Re-render chart with new view
                    if (currentDomainData && currentDomainName) {
                        // Get current date range selection
                        const dateRangeSelect = document.getElementById('chartDateRange');
                        const currentDateRange = dateRangeSelect ? dateRangeSelect.value : 'dec2024';
                        createChart(currentDomainName, currentDomainData, currentDateRange);
                    }
                });
            });
        }

        // Calculate revenue rankings across all domains
        function calculateRevenueRankings(revenueByDomain) {
            const domainList = Object.keys(revenueByDomain);
            
            // Calculate totals for each ranking type
            const lifetimeRevenue = {};
            const last3MonthRevenue = {};
            const currentMonthRevenue = {};
            
            // Define the months for last 3 and current
            const currentMonth = 'Jan2026';
            const last3Months = ['Nov2025', 'Dec2025', 'Jan2026'];
            
            domainList.forEach(domain => {
                const revenue = revenueByDomain[domain];
                lifetimeRevenue[domain] = Object.values(revenue).reduce((a, b) => a + b, 0);
                last3MonthRevenue[domain] = last3Months.reduce((sum, m) => sum + (revenue[m] || 0), 0);
                currentMonthRevenue[domain] = revenue[currentMonth] || 0;
            });
            
            // Calculate portfolio totals
            const portfolioTotals = {
                lifetime: Object.values(lifetimeRevenue).reduce((a, b) => a + b, 0),
                last3Month: Object.values(last3MonthRevenue).reduce((a, b) => a + b, 0),
                currentMonth: Object.values(currentMonthRevenue).reduce((a, b) => a + b, 0)
            };
            
            // Sort and assign ranks (1 = highest revenue)
            const sortAndRank = (obj) => {
                const sorted = Object.entries(obj).sort((a, b) => b[1] - a[1]);
                const ranks = {};
                sorted.forEach(([domain], idx) => ranks[domain] = idx + 1);
                return ranks;
            };
            
            return {
                lifetime: sortAndRank(lifetimeRevenue),
                last3Month: sortAndRank(last3MonthRevenue),
                currentMonth: sortAndRank(currentMonthRevenue),
                values: {
                    lifetime: lifetimeRevenue,
                    last3Month: last3MonthRevenue,
                    currentMonth: currentMonthRevenue
                },
                totals: portfolioTotals
            };
        }

        // CSV Loading Functions
        function parseCurrency(value) {
            if (!value || value === '' || value === '-') return 0;
            const cleaned = String(value).replace(/[$,]/g, '');
            return parseFloat(cleaned) || 0;
        }

        function parseNumber(value) {
            if (!value || value === '' || value === '-') return null;
            const cleaned = String(value).replace(/,/g, '');
            const num = parseInt(cleaned, 10);
            return isNaN(num) ? null : num;
        }

        function parseDate(dateStr) {
            // Convert "Jun 4 - 2025_1" to "Jun 4 2025" (remove dashes and _1/_2 suffixes)
            return dateStr.replace(/\s*-\s*/g, ' ').replace(/_\d+$/, '').trim();
        }

        function dateInRange(dateStr, startDate, endDate) {
            const date = parseDate(dateStr);
            const parts = date.split(' ');
            if (parts.length !== 3) return false;
            
            const [month, day, year] = parts;
            const dateObj = new Date(`${month} ${day}, ${year}`);
            const start = new Date(startDate);
            const end = new Date(endDate);
            
            return dateObj >= start && dateObj <= end;
        }

        // List of domains to load (Top 100)
        const TARGET_DOMAINS = [
            'decoratoradvice.com',
            'traveltweaks.com',
            'famousparenting.com',
            'etruesports.com',
            'betterthisworld.com',
            'lookwhatmomfound.com',
            'activepropertycare.com',
            'redandwhitemagz.com',
            'lyncconf.com',
            'playmyworld.com',
            'mygreenbucks.net',
            'disquantified.org',
            'whatutalkingboutwillis.com',
            'arcyart.com',
            'sportsfanfare.com',
            'thegamearchives.com',
            'freelogopng.com',
            'avstarnews.com',
            'digitalnewsalerts.com',
            'mywirelesscoupons.com',
            'healthsciencesforum.com',
            'oneframework.net',
            'entretech.org',
            'thinkofgames.com',
            'harmonicode.com',
            'conversationswithbianca.com',
            'pushyourdesign.com',
            'alternativeway.net',
            'etherions.com',
            'letsbuildup.org',
            'mucicallydown.com',
            'electronmagazine.com',
            'onthisveryspot.com',
            'musikcalldown.com',
            'undergrowthgames.com',
            'thunderonthegulf.com',
            'nothing2hide.net',
            'feedbuzzard.com',
            'thestripesblog.com',
            'wealthybyte.com',
            'smartsatta.com',
            'waptirick.com',
            'kdarchitects.net',
            'beaconsoft.net',
            'hearthstats.net',
            'crypticstreet.com',
            'reactcheck.com',
            'musikcalidown.com',
            'gamificationsummit.com',
            'myfavouriteplaces.org',
            'geekgadget.net',
            'fintechasia.net',
            'luxuryinteriors.org',
            'greenheal.net',
            'livingpristine.com',
            'thehake.com',
            'icaiorg.net',
            'flyarchitecture.net',
            'springhillmedgroup.com',
            'revolvertech.com',
            'logicalshout.com',
            'thehometrotters.com',
            'voicesofconservation.org',
            'turbogeek.org',
            'gfxmaker.com',
            'drhomey.com',
            'filmyzillah.com',
            'sentback.org',
            'leopardtheme.com',
            'webtosociety.com',
            'w88w88hanoi.com',
            'bageltechnews.com',
            'bitnation-blog.com',
            'fameblogs.net',
            'g15tools.com',
            'designmode24.com',
            'dhilisatta.com',
            'defstartup.org',
            'tubitymusic.com',
            'cloudysocial.com',
            'theblockchainbrief.com',
            'moneysideoflife.com',
            'playdedeus.com',
            'anwire.org',
            'thechannelrace.org',
            'theboringmagazine.com',
            'embedtree.com',
            'metsuiteorg.com',
            'eyexcon.com',
            'aliensync.com',
            'conversationswithgreg.com',
            'pondershort.com',
            'formotorbikes.com',
            'myinteriorpalace.com',
            'sportsblitzzone.com',
            'prositesite.com',
            'javaobjects.net',
            'socceragency.net',
            'proxcroxy.com',
            'silicon-insider.com'
        ];

        async function loadRevenueCSV() {
            try {
                const response = await fetch('revenue-history.csv');
                if (!response.ok) throw new Error('Failed to load revenue CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const headers = parsed.meta.fields || [];
                const revenueByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    if (row) {
                        const monthlyRevenue = {};
                        headers.forEach(header => {
                            const monthMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/);
                            if (monthMatch) {
                                const [, month, year] = monthMatch;
                                const key = month + year;
                                const value = parseCurrency(row[header]);
                                // Include all values including $0 (but not empty/dash)
                                if (value >= 0 && row[header] && row[header] !== '-') {
                                    monthlyRevenue[key] = value;
                                }
                            }
                        });
                        revenueByDomain[domain] = monthlyRevenue;
                    } else {
                        revenueByDomain[domain] = {};
                    }
                });
                
                console.log('âœ… Revenue data loaded for domains:', Object.keys(revenueByDomain));
                return revenueByDomain;
            } catch (error) {
                console.error('Error loading revenue CSV:', error);
                throw error;
            }
        }

        async function loadDRHistoryCSV() {
            try {
                const response = await fetch('DR History.csv');
                if (!response.ok) throw new Error('Failed to load DR History CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const headers = parsed.meta.fields || [];
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const drByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const drDataMap = new Map();
                    
                    if (row) {
                        headers.forEach(header => {
                            // Match date format like "Jul 1 - 2024" or "Jan 20 - 2026"
                            const dateMatch = header.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+)\s*-\s*(\d{4})$/);
                            if (dateMatch) {
                                const [, month, day, year] = dateMatch;
                                const dateStr = `${month} ${day} ${year}`;
                                const value = parseNumber(row[header]);
                                if (value !== null && value !== undefined) {
                                    // Only keep first occurrence of each date
                                    if (!drDataMap.has(dateStr)) {
                                        drDataMap.set(dateStr, value);
                                    }
                                }
                            }
                        });
                    }
                    
                    drByDomain[domain] = drDataMap;
                });
                
                console.log('âœ… DR History data loaded for domains:', Object.keys(drByDomain).map(d => `${d}: ${drByDomain[d].size} points`));
                return drByDomain;
            } catch (error) {
                console.error('Error loading DR History CSV:', error);
                throw error;
            }
        }

        async function loadAhrefsCSV() {
            try {
                const response = await fetch('ahrefs_organic_traffic_results.csv');
                if (!response.ok) throw new Error('Failed to load Ahrefs CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const ahrefsByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const ahrefsDataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.organic_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.organic_traffic);
                        if (value !== null && value !== undefined) {
                            ahrefsDataMap.set(dateStr, value);
                        }
                    });
                    
                    ahrefsByDomain[domain] = ahrefsDataMap;
                });
                
                console.log('âœ… Ahrefs data loaded for domains:', Object.keys(ahrefsByDomain).map(d => `${d}: ${ahrefsByDomain[d].size} points`));
                return ahrefsByDomain;
            } catch (error) {
                console.error('Error loading Ahrefs CSV:', error);
                throw error;
            }
        }

        async function loadInternalAverageCSV() {
            try {
                const response = await fetch('internal-average-traffic.csv');
                if (!response.ok) throw new Error('Failed to load Internal Average CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const internalAvgByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const dataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.average_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.average_traffic);
                        if (value !== null && value !== undefined) {
                            dataMap.set(dateStr, value);
                        }
                    });
                    
                    internalAvgByDomain[domain] = dataMap;
                });
                
                console.log('âœ… Internal Average data loaded for domains:', Object.keys(internalAvgByDomain).filter(d => internalAvgByDomain[d].size > 0).map(d => `${d}: ${internalAvgByDomain[d].size} points`));
                return internalAvgByDomain;
            } catch (error) {
                console.warn('Warning loading Internal Average CSV:', error);
                // Return empty maps - graceful degradation
                const emptyResult = {};
                TARGET_DOMAINS.forEach(domain => emptyResult[domain] = new Map());
                return emptyResult;
            }
        }

        async function loadAhrefsAverageCSV() {
            try {
                const response = await fetch('ahrefs-average-traffic.csv');
                if (!response.ok) throw new Error('Failed to load Ahrefs Average CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: true
                });
                
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const ahrefsAvgByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const domainRows = parsed.data.filter(row => 
                        row.domain && row.domain.toLowerCase() === domain.toLowerCase()
                    );
                    
                    const dataMap = new Map();
                    domainRows.forEach(row => {
                        if (!row.date || !row.average_traffic) return;
                        
                        const isoDate = new Date(row.date);
                        if (isNaN(isoDate.getTime())) return;
                        
                        const month = monthNames[isoDate.getMonth()];
                        const day = isoDate.getDate();
                        const year = isoDate.getFullYear();
                        const dateStr = `${month} ${day} ${year}`;
                        
                        const value = parseNumber(row.average_traffic);
                        if (value !== null && value !== undefined) {
                            dataMap.set(dateStr, value);
                        }
                    });
                    
                    ahrefsAvgByDomain[domain] = dataMap;
                });
                
                console.log('âœ… Ahrefs Average data loaded for domains:', Object.keys(ahrefsAvgByDomain).filter(d => ahrefsAvgByDomain[d].size > 0).map(d => `${d}: ${ahrefsAvgByDomain[d].size} points`));
                return ahrefsAvgByDomain;
            } catch (error) {
                console.warn('Warning loading Ahrefs Average CSV:', error);
                // Return empty maps - graceful degradation
                const emptyResult = {};
                TARGET_DOMAINS.forEach(domain => emptyResult[domain] = new Map());
                return emptyResult;
            }
        }

        async function loadTrafficCSV() {
            try {
                const response = await fetch('traffic-data.csv');
                if (!response.ok) throw new Error('Failed to load traffic CSV');
                
                const text = await response.text();
                const parsed = Papa.parse(text, { 
                    header: true,
                    skipEmptyLines: false,
                    transformHeader: (header) => header.trim()
                });
                
                const headers = parsed.meta.fields || [];
                const dateColumns = headers.slice(6); // Skip first 6 metadata columns
                
                // Build date info once (shared across all domains)
                const seenDates = new Map();
                dateColumns.forEach((header, idx) => {
                    if (!header || header.trim() === '') return;
                    const dateStr = parseDate(header);
                    if (!dateStr || dateStr === '') return;
                    if (!seenDates.has(dateStr)) {
                        seenDates.set(dateStr, { firstIndex: idx, secondIndex: -1, headers: [header] });
                    } else {
                        const entry = seenDates.get(dateStr);
                        if (entry.secondIndex === -1) entry.secondIndex = idx;
                        entry.headers.push(header);
                    }
                });
                
                let splitPoint = -1;
                seenDates.forEach((entry) => {
                    if (entry.secondIndex !== -1 && (splitPoint === -1 || entry.secondIndex < splitPoint)) {
                        splitPoint = entry.secondIndex;
                    }
                });
                
                const trafficByDomain = {};
                
                // Process each target domain
                TARGET_DOMAINS.forEach(domain => {
                    const row = parsed.data.find(r => 
                        r.Website && r.Website.toLowerCase() === domain.toLowerCase()
                    );
                    
                    if (!row) {
                        trafficByDomain[domain] = { dates: [], ourData: [] };
                        return;
                    }
                    
                    const ourDataMap = new Map();
                    
                    dateColumns.forEach((header, idx) => {
                        if (!header || header.trim() === '') return;
                        
                        const suffixMatch = header.match(/_(\d+)$/);
                        const hasSuffix = suffixMatch !== null;
                        const headerForDate = hasSuffix ? header.replace(/_(\d+)$/, '') : header;
                        const dateStr = parseDate(headerForDate);
                        if (!dateStr || dateStr === '') return;
                        
                        const parts = dateStr.split(' ');
                        if (parts.length !== 3) return;
                        
                        const [month, day, year] = parts;
                        const dateObj = new Date(`${month} ${day}, ${year}`);
                        if (isNaN(dateObj.getTime())) return;
                        
                        const value = parseNumber(row[header]);
                        
                        // Only use first occurrence (our data), skip duplicates
                        let isOurData = !hasSuffix;
                        if (!hasSuffix && splitPoint > 0 && idx >= splitPoint) {
                            const entry = seenDates.get(dateStr);
                            if (entry && entry.secondIndex !== -1 && idx >= entry.secondIndex) {
                                isOurData = false;
                            }
                        }
                        
                        if (isOurData && !ourDataMap.has(dateStr)) {
                            ourDataMap.set(dateStr, value);
                        }
                    });
                    
                    // Sort dates chronologically
                    const sortedDates = Array.from(ourDataMap.keys()).sort((a, b) => {
                        const parseD = (s) => {
                            const p = s.split(' ');
                            return new Date(`${p[0]} ${p[1]}, ${p[2]}`);
                        };
                        return parseD(a) - parseD(b);
                    });
                    
                    const sortedOurData = sortedDates.map(d => ourDataMap.get(d));
                    
                    trafficByDomain[domain] = { dates: sortedDates, ourData: sortedOurData };
                });
                
                console.log('âœ… Traffic data loaded for domains:', Object.keys(trafficByDomain).map(d => `${d}: ${trafficByDomain[d].dates.length} dates`));
                return trafficByDomain;
            } catch (error) {
                console.error('Error loading traffic CSV:', error);
                throw error;
            }
        }

        function initializeDashboard(data) {
            domains = data;
            
            // Setup event listeners
            setupDomainSelector();
            setupRevenueToggle(); // REVENUE LABEL CHANGE
            setupViewToggle(); // VIEW TOGGLE
            
            // Check for URL parameter to pre-select domain
            const urlParams = new URLSearchParams(window.location.search);
            const domainParam = urlParams.get('domain');
            
            // Determine which domain to show
            let targetDomain = null;
            if (domainParam && domains[domainParam]) {
                targetDomain = domainParam;
            } else if (Object.keys(domains).length > 0) {
                targetDomain = Object.keys(domains)[0];
            }
            
            if (targetDomain) {
                selectedDomain = targetDomain;
                document.getElementById('domainSearch').value = targetDomain;
                createChart(targetDomain, domains[targetDomain]);
            }
        }

        async function loadDataFromCSV() {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const errorMsg = document.getElementById('error-message');
            const chartsEl = document.getElementById('charts');
            
            // Check if we're on file:// protocol (CSV won't work)
            const isFileProtocol = window.location.protocol === 'file:';
            
            if (isFileProtocol) {
                // Use fallback immediately for file:// protocol
                console.log('File protocol detected - using fallback data');
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
                return;
            }
            
            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                chartsEl.innerHTML = '';
                
                // Set timeout for CSV loading (5 seconds max)
                const timeoutPromise = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('CSV loading timeout')), 5000)
                );
                
                const [revenueByDomain, trafficByDomain, ahrefsByDomain, drByDomain, internalAvgByDomain, ahrefsAvgByDomain] = await Promise.race([
                    Promise.all([loadRevenueCSV(), loadTrafficCSV(), loadAhrefsCSV(), loadDRHistoryCSV(), loadInternalAverageCSV(), loadAhrefsAverageCSV()]),
                    timeoutPromise
                ]);
                
                // Calculate revenue rankings across all domains
                const revenueRankings = calculateRevenueRankings(revenueByDomain);
                console.log('âœ… Revenue rankings calculated:', revenueRankings);
                
                // Helper to sort dates
                const parseDateForSort = (dateStr) => {
                    const parts = dateStr.split(' ');
                    if (parts.length !== 3) return new Date(0);
                    const [month, day, year] = parts;
                    return new Date(`${month} ${day}, ${year}`);
                };
                
                // Build domains object for all target domains
                domains = {};
                
                TARGET_DOMAINS.forEach((domain, idx) => {
                    const trafficData = trafficByDomain[domain] || { dates: [], ourData: [] };
                    const ahrefsDataMap = ahrefsByDomain[domain] || new Map();
                    const revenueData = revenueByDomain[domain] || {};
                    const drDataMap = drByDomain[domain] || new Map();
                    const internalAvgMap = internalAvgByDomain[domain] || new Map();
                    const ahrefsAvgMap = ahrefsAvgByDomain[domain] || new Map();
                    
                    // Merge all dates from traffic, ahrefs, DR, and averages
                    const allDatesSet = new Set();
                    trafficData.dates.forEach(d => allDatesSet.add(d));
                    ahrefsDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                    drDataMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                    internalAvgMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                    ahrefsAvgMap.forEach((value, dateStr) => allDatesSet.add(dateStr));
                    
                    // Add revenue dates
                    Object.keys(revenueData).forEach(monthKey => {
                        const noSpaceMatch = monthKey.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)(\d{4})$/);
                        if (noSpaceMatch) {
                            const [, month, year] = noSpaceMatch;
                            allDatesSet.add(`${month} 1 ${year}`);
                        }
                    });
                    
                    // Sort dates
                    const allDates = Array.from(allDatesSet).sort((a, b) => parseDateForSort(a) - parseDateForSort(b));
                    
                    // Build arrays
                    const ourDataMap = new Map();
                    trafficData.dates.forEach((date, i) => ourDataMap.set(date, trafficData.ourData[i]));
                    
                    const mergedDates = [];
                    const mergedOurData = [];
                    const mergedAhrefsData = [];
                    const mergedDRData = [];
                    const mergedInternalAvgData = [];
                    const mergedAhrefsAvgData = [];
                    
                    allDates.forEach(dateStr => {
                        mergedDates.push(dateStr);
                        mergedOurData.push(ourDataMap.get(dateStr) || null);
                        mergedAhrefsData.push(ahrefsDataMap.get(dateStr) || null);
                        mergedDRData.push(drDataMap.get(dateStr) || null);
                        mergedInternalAvgData.push(internalAvgMap.get(dateStr) || null);
                        mergedAhrefsAvgData.push(ahrefsAvgMap.get(dateStr) || null);
                    });
                    
                    // Get revenue values and calculate percentages
                    const lifetimeVal = revenueRankings.values.lifetime[domain] || 0;
                    const last3MonthVal = revenueRankings.values.last3Month[domain] || 0;
                    const currentMonthVal = revenueRankings.values.currentMonth[domain] || 0;
                    
                    const lifetimePct = revenueRankings.totals.lifetime > 0 
                        ? (lifetimeVal / revenueRankings.totals.lifetime * 100).toFixed(2) : 0;
                    const last3MonthPct = revenueRankings.totals.last3Month > 0 
                        ? (last3MonthVal / revenueRankings.totals.last3Month * 100).toFixed(2) : 0;
                    const currentMonthPct = revenueRankings.totals.currentMonth > 0 
                        ? (currentMonthVal / revenueRankings.totals.currentMonth * 100).toFixed(2) : 0;
                    
                    domains[domain] = {
                        rank: idx + 1,
                        dates: mergedDates,
                        ourData: mergedOurData,
                        ahrefsData: mergedAhrefsData,
                        drData: mergedDRData,
                        internalAvgData: mergedInternalAvgData,
                        ahrefsAvgData: mergedAhrefsAvgData,
                        monthlyRevenue: revenueData,
                        revenueRankings: {
                            lifetime: revenueRankings.lifetime[domain] || TARGET_DOMAINS.length,
                            last3Month: revenueRankings.last3Month[domain] || TARGET_DOMAINS.length,
                            currentMonth: revenueRankings.currentMonth[domain] || TARGET_DOMAINS.length,
                            lifetimeValue: lifetimeVal,
                            last3MonthValue: last3MonthVal,
                            currentMonthValue: currentMonthVal,
                            lifetimePct: lifetimePct,
                            last3MonthPct: last3MonthPct,
                            currentMonthPct: currentMonthPct
                        }
                    };
                });
                
                console.log('âœ… Data merged for all domains:', Object.keys(domains).map(d => 
                    `${d}: ${domains[d].dates.length} dates, ${domains[d].ourData.filter(v => v !== null).length} traffic pts, ${domains[d].drData.filter(v => v !== null).length} DR pts`
                ));
                
                loadingEl.style.display = 'none';
                initializeDashboard(domains);
            } catch (error) {
                // Fallback to hardcoded data on any error
                console.warn('CSV loading failed, using fallback data:', error);
                loadingEl.style.display = 'none';
                errorEl.style.display = 'none';
                initializeDashboard(fallbackData);
            }
        }

        // Initialize on page load - try CSV first, fallback to hardcoded
        loadDataFromCSV();

        // Check authentication and load user info
        async function checkAuthAndLoadUser() {
            try {
                const response = await fetch('/api/auth/check');
                const data = await response.json();
                
                if (!data.authenticated) {
                    // Not authenticated - redirect to login
                    window.location.href = '/api/auth/login?redirect=' + encodeURIComponent(window.location.pathname + window.location.search);
                    return;
                }
                
                // Authenticated - show the page and load user info
                document.body.style.visibility = 'visible';
                
                const meResponse = await fetch('/api/auth/me');
                const meData = await meResponse.json();
                if (meData.authenticated && meData.email) {
                    document.getElementById('userEmail').textContent = meData.email;
                    document.getElementById('userBar').style.display = 'flex';
                }
            } catch (error) {
                console.log('Auth check failed, showing page anyway');
                document.body.style.visibility = 'visible';
            }
        }
        checkAuthAndLoadUser();
    </script>
</body>
</html>
